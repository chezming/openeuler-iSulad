// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: api.proto
// Original file comments:
//
// Copyright 2018 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// To regenerate api.pb.go run hack/update-generated-runtime.sh
#ifndef GRPC_api_2eproto__INCLUDED
#define GRPC_api_2eproto__INCLUDED

#include "api.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace runtime {
namespace v1alpha2 {

// Runtime service defines the public APIs for remote container runtimes
class RuntimeService final {
 public:
  static constexpr char const* service_full_name() {
    return "runtime.v1alpha2.RuntimeService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Version returns the runtime name, runtime version, and runtime API version.
    virtual ::grpc::Status Version(::grpc::ClientContext* context, const ::runtime::v1alpha2::VersionRequest& request, ::runtime::v1alpha2::VersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::VersionResponse>> AsyncVersion(::grpc::ClientContext* context, const ::runtime::v1alpha2::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::VersionResponse>>(AsyncVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::VersionResponse>> PrepareAsyncVersion(::grpc::ClientContext* context, const ::runtime::v1alpha2::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::VersionResponse>>(PrepareAsyncVersionRaw(context, request, cq));
    }
    // RunPodSandbox creates and starts a pod-level sandbox. Runtimes must ensure
    // the sandbox is in the ready state on success.
    virtual ::grpc::Status RunPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RunPodSandboxRequest& request, ::runtime::v1alpha2::RunPodSandboxResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RunPodSandboxResponse>> AsyncRunPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RunPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RunPodSandboxResponse>>(AsyncRunPodSandboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RunPodSandboxResponse>> PrepareAsyncRunPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RunPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RunPodSandboxResponse>>(PrepareAsyncRunPodSandboxRaw(context, request, cq));
    }
    // StopPodSandbox stops any running process that is part of the sandbox and
    // reclaims network resources (e.g., IP addresses) allocated to the sandbox.
    // If there are any running containers in the sandbox, they must be forcibly
    // terminated.
    // This call is idempotent, and must not return an error if all relevant
    // resources have already been reclaimed. kubelet will call StopPodSandbox
    // at least once before calling RemovePodSandbox. It will also attempt to
    // reclaim resources eagerly, as soon as a sandbox is not needed. Hence,
    // multiple StopPodSandbox calls are expected.
    virtual ::grpc::Status StopPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopPodSandboxRequest& request, ::runtime::v1alpha2::StopPodSandboxResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StopPodSandboxResponse>> AsyncStopPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StopPodSandboxResponse>>(AsyncStopPodSandboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StopPodSandboxResponse>> PrepareAsyncStopPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StopPodSandboxResponse>>(PrepareAsyncStopPodSandboxRaw(context, request, cq));
    }
    // RemovePodSandbox removes the sandbox. If there are any running containers
    // in the sandbox, they must be forcibly terminated and removed.
    // This call is idempotent, and must not return an error if the sandbox has
    // already been removed.
    virtual ::grpc::Status RemovePodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemovePodSandboxRequest& request, ::runtime::v1alpha2::RemovePodSandboxResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemovePodSandboxResponse>> AsyncRemovePodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemovePodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemovePodSandboxResponse>>(AsyncRemovePodSandboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemovePodSandboxResponse>> PrepareAsyncRemovePodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemovePodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemovePodSandboxResponse>>(PrepareAsyncRemovePodSandboxRaw(context, request, cq));
    }
    // PodSandboxStatus returns the status of the PodSandbox. If the PodSandbox is not
    // present, returns an error.
    virtual ::grpc::Status PodSandboxStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatusRequest& request, ::runtime::v1alpha2::PodSandboxStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PodSandboxStatusResponse>> AsyncPodSandboxStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PodSandboxStatusResponse>>(AsyncPodSandboxStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PodSandboxStatusResponse>> PrepareAsyncPodSandboxStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PodSandboxStatusResponse>>(PrepareAsyncPodSandboxStatusRaw(context, request, cq));
    }
    // ListPodSandbox returns a list of PodSandboxes.
    virtual ::grpc::Status ListPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxRequest& request, ::runtime::v1alpha2::ListPodSandboxResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListPodSandboxResponse>> AsyncListPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListPodSandboxResponse>>(AsyncListPodSandboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListPodSandboxResponse>> PrepareAsyncListPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListPodSandboxResponse>>(PrepareAsyncListPodSandboxRaw(context, request, cq));
    }
    // CreateContainer creates a new container in specified PodSandbox
    virtual ::grpc::Status CreateContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::CreateContainerRequest& request, ::runtime::v1alpha2::CreateContainerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::CreateContainerResponse>> AsyncCreateContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::CreateContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::CreateContainerResponse>>(AsyncCreateContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::CreateContainerResponse>> PrepareAsyncCreateContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::CreateContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::CreateContainerResponse>>(PrepareAsyncCreateContainerRaw(context, request, cq));
    }
    // StartContainer starts the container.
    virtual ::grpc::Status StartContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StartContainerRequest& request, ::runtime::v1alpha2::StartContainerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StartContainerResponse>> AsyncStartContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StartContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StartContainerResponse>>(AsyncStartContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StartContainerResponse>> PrepareAsyncStartContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StartContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StartContainerResponse>>(PrepareAsyncStartContainerRaw(context, request, cq));
    }
    // StopContainer stops a running container with a grace period (i.e., timeout).
    // This call is idempotent, and must not return an error if the container has
    // already been stopped.
    // The runtime must forcibly kill the container after the grace period is
    // reached.
    virtual ::grpc::Status StopContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopContainerRequest& request, ::runtime::v1alpha2::StopContainerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StopContainerResponse>> AsyncStopContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StopContainerResponse>>(AsyncStopContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StopContainerResponse>> PrepareAsyncStopContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StopContainerResponse>>(PrepareAsyncStopContainerRaw(context, request, cq));
    }
    // RemoveContainer removes the container. If the container is running, the
    // container must be forcibly removed.
    // This call is idempotent, and must not return an error if the container has
    // already been removed.
    virtual ::grpc::Status RemoveContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveContainerRequest& request, ::runtime::v1alpha2::RemoveContainerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemoveContainerResponse>> AsyncRemoveContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemoveContainerResponse>>(AsyncRemoveContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemoveContainerResponse>> PrepareAsyncRemoveContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemoveContainerResponse>>(PrepareAsyncRemoveContainerRaw(context, request, cq));
    }
    // ListContainers lists all containers by filters.
    virtual ::grpc::Status ListContainers(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainersRequest& request, ::runtime::v1alpha2::ListContainersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListContainersResponse>> AsyncListContainers(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListContainersResponse>>(AsyncListContainersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListContainersResponse>> PrepareAsyncListContainers(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListContainersResponse>>(PrepareAsyncListContainersRaw(context, request, cq));
    }
    // ContainerStatus returns status of the container. If the container is not
    // present, returns an error.
    virtual ::grpc::Status ContainerStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatusRequest& request, ::runtime::v1alpha2::ContainerStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ContainerStatusResponse>> AsyncContainerStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ContainerStatusResponse>>(AsyncContainerStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ContainerStatusResponse>> PrepareAsyncContainerStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ContainerStatusResponse>>(PrepareAsyncContainerStatusRaw(context, request, cq));
    }
    // UpdateContainerResources updates ContainerConfig of the container synchronously.
    // If runtime fails to transactionally update the requested resources, an error is returned.
    virtual ::grpc::Status UpdateContainerResources(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateContainerResourcesRequest& request, ::runtime::v1alpha2::UpdateContainerResourcesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::UpdateContainerResourcesResponse>> AsyncUpdateContainerResources(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateContainerResourcesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::UpdateContainerResourcesResponse>>(AsyncUpdateContainerResourcesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::UpdateContainerResourcesResponse>> PrepareAsyncUpdateContainerResources(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateContainerResourcesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::UpdateContainerResourcesResponse>>(PrepareAsyncUpdateContainerResourcesRaw(context, request, cq));
    }
    // ReopenContainerLog asks runtime to reopen the stdout/stderr log file
    // for the container. This is often called after the log file has been
    // rotated. If the container is not running, container runtime can choose
    // to either create a new log file and return nil, or return an error.
    // Once it returns error, new container log file MUST NOT be created.
    virtual ::grpc::Status ReopenContainerLog(::grpc::ClientContext* context, const ::runtime::v1alpha2::ReopenContainerLogRequest& request, ::runtime::v1alpha2::ReopenContainerLogResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ReopenContainerLogResponse>> AsyncReopenContainerLog(::grpc::ClientContext* context, const ::runtime::v1alpha2::ReopenContainerLogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ReopenContainerLogResponse>>(AsyncReopenContainerLogRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ReopenContainerLogResponse>> PrepareAsyncReopenContainerLog(::grpc::ClientContext* context, const ::runtime::v1alpha2::ReopenContainerLogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ReopenContainerLogResponse>>(PrepareAsyncReopenContainerLogRaw(context, request, cq));
    }
    // ExecSync runs a command in a container synchronously.
    virtual ::grpc::Status ExecSync(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecSyncRequest& request, ::runtime::v1alpha2::ExecSyncResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ExecSyncResponse>> AsyncExecSync(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ExecSyncResponse>>(AsyncExecSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ExecSyncResponse>> PrepareAsyncExecSync(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ExecSyncResponse>>(PrepareAsyncExecSyncRaw(context, request, cq));
    }
    // Exec prepares a streaming endpoint to execute a command in the container.
    virtual ::grpc::Status Exec(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecRequest& request, ::runtime::v1alpha2::ExecResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ExecResponse>> AsyncExec(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ExecResponse>>(AsyncExecRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ExecResponse>> PrepareAsyncExec(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ExecResponse>>(PrepareAsyncExecRaw(context, request, cq));
    }
    // Attach prepares a streaming endpoint to attach to a running container.
    virtual ::grpc::Status Attach(::grpc::ClientContext* context, const ::runtime::v1alpha2::AttachRequest& request, ::runtime::v1alpha2::AttachResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::AttachResponse>> AsyncAttach(::grpc::ClientContext* context, const ::runtime::v1alpha2::AttachRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::AttachResponse>>(AsyncAttachRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::AttachResponse>> PrepareAsyncAttach(::grpc::ClientContext* context, const ::runtime::v1alpha2::AttachRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::AttachResponse>>(PrepareAsyncAttachRaw(context, request, cq));
    }
    // PortForward prepares a streaming endpoint to forward ports from a PodSandbox.
    virtual ::grpc::Status PortForward(::grpc::ClientContext* context, const ::runtime::v1alpha2::PortForwardRequest& request, ::runtime::v1alpha2::PortForwardResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PortForwardResponse>> AsyncPortForward(::grpc::ClientContext* context, const ::runtime::v1alpha2::PortForwardRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PortForwardResponse>>(AsyncPortForwardRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PortForwardResponse>> PrepareAsyncPortForward(::grpc::ClientContext* context, const ::runtime::v1alpha2::PortForwardRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PortForwardResponse>>(PrepareAsyncPortForwardRaw(context, request, cq));
    }
    // ContainerStats returns stats of the container. If the container does not
    // exist, the call returns an error.
    virtual ::grpc::Status ContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatsRequest& request, ::runtime::v1alpha2::ContainerStatsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ContainerStatsResponse>> AsyncContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ContainerStatsResponse>>(AsyncContainerStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ContainerStatsResponse>> PrepareAsyncContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ContainerStatsResponse>>(PrepareAsyncContainerStatsRaw(context, request, cq));
    }
    // ListContainerStats returns stats of all running containers.
    virtual ::grpc::Status ListContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainerStatsRequest& request, ::runtime::v1alpha2::ListContainerStatsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListContainerStatsResponse>> AsyncListContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainerStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListContainerStatsResponse>>(AsyncListContainerStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListContainerStatsResponse>> PrepareAsyncListContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainerStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListContainerStatsResponse>>(PrepareAsyncListContainerStatsRaw(context, request, cq));
    }
    // PodSandboxStats returns stats of the pod sandbox. If the pod sandbox does not
    // exist, the call returns an error.
    virtual ::grpc::Status PodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatsRequest& request, ::runtime::v1alpha2::PodSandboxStatsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PodSandboxStatsResponse>> AsyncPodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PodSandboxStatsResponse>>(AsyncPodSandboxStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PodSandboxStatsResponse>> PrepareAsyncPodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PodSandboxStatsResponse>>(PrepareAsyncPodSandboxStatsRaw(context, request, cq));
    }
    // ListPodSandboxStats returns stats of the pod sandboxes matching a filter.
    virtual ::grpc::Status ListPodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxStatsRequest& request, ::runtime::v1alpha2::ListPodSandboxStatsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListPodSandboxStatsResponse>> AsyncListPodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListPodSandboxStatsResponse>>(AsyncListPodSandboxStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListPodSandboxStatsResponse>> PrepareAsyncListPodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListPodSandboxStatsResponse>>(PrepareAsyncListPodSandboxStatsRaw(context, request, cq));
    }
    // UpdateRuntimeConfig updates the runtime configuration based on the given request.
    virtual ::grpc::Status UpdateRuntimeConfig(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest& request, ::runtime::v1alpha2::UpdateRuntimeConfigResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::UpdateRuntimeConfigResponse>> AsyncUpdateRuntimeConfig(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::UpdateRuntimeConfigResponse>>(AsyncUpdateRuntimeConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::UpdateRuntimeConfigResponse>> PrepareAsyncUpdateRuntimeConfig(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::UpdateRuntimeConfigResponse>>(PrepareAsyncUpdateRuntimeConfigRaw(context, request, cq));
    }
    // Status returns the status of the runtime.
    virtual ::grpc::Status Status(::grpc::ClientContext* context, const ::runtime::v1alpha2::StatusRequest& request, ::runtime::v1alpha2::StatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StatusResponse>> AsyncStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::StatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StatusResponse>>(AsyncStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StatusResponse>> PrepareAsyncStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::StatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StatusResponse>>(PrepareAsyncStatusRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Version returns the runtime name, runtime version, and runtime API version.
      virtual void Version(::grpc::ClientContext* context, const ::runtime::v1alpha2::VersionRequest* request, ::runtime::v1alpha2::VersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Version(::grpc::ClientContext* context, const ::runtime::v1alpha2::VersionRequest* request, ::runtime::v1alpha2::VersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // RunPodSandbox creates and starts a pod-level sandbox. Runtimes must ensure
      // the sandbox is in the ready state on success.
      virtual void RunPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RunPodSandboxRequest* request, ::runtime::v1alpha2::RunPodSandboxResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RunPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RunPodSandboxRequest* request, ::runtime::v1alpha2::RunPodSandboxResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // StopPodSandbox stops any running process that is part of the sandbox and
      // reclaims network resources (e.g., IP addresses) allocated to the sandbox.
      // If there are any running containers in the sandbox, they must be forcibly
      // terminated.
      // This call is idempotent, and must not return an error if all relevant
      // resources have already been reclaimed. kubelet will call StopPodSandbox
      // at least once before calling RemovePodSandbox. It will also attempt to
      // reclaim resources eagerly, as soon as a sandbox is not needed. Hence,
      // multiple StopPodSandbox calls are expected.
      virtual void StopPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopPodSandboxRequest* request, ::runtime::v1alpha2::StopPodSandboxResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopPodSandboxRequest* request, ::runtime::v1alpha2::StopPodSandboxResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // RemovePodSandbox removes the sandbox. If there are any running containers
      // in the sandbox, they must be forcibly terminated and removed.
      // This call is idempotent, and must not return an error if the sandbox has
      // already been removed.
      virtual void RemovePodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemovePodSandboxRequest* request, ::runtime::v1alpha2::RemovePodSandboxResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RemovePodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemovePodSandboxRequest* request, ::runtime::v1alpha2::RemovePodSandboxResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // PodSandboxStatus returns the status of the PodSandbox. If the PodSandbox is not
      // present, returns an error.
      virtual void PodSandboxStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatusRequest* request, ::runtime::v1alpha2::PodSandboxStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PodSandboxStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatusRequest* request, ::runtime::v1alpha2::PodSandboxStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ListPodSandbox returns a list of PodSandboxes.
      virtual void ListPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxRequest* request, ::runtime::v1alpha2::ListPodSandboxResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxRequest* request, ::runtime::v1alpha2::ListPodSandboxResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // CreateContainer creates a new container in specified PodSandbox
      virtual void CreateContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::CreateContainerRequest* request, ::runtime::v1alpha2::CreateContainerResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::CreateContainerRequest* request, ::runtime::v1alpha2::CreateContainerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // StartContainer starts the container.
      virtual void StartContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StartContainerRequest* request, ::runtime::v1alpha2::StartContainerResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StartContainerRequest* request, ::runtime::v1alpha2::StartContainerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // StopContainer stops a running container with a grace period (i.e., timeout).
      // This call is idempotent, and must not return an error if the container has
      // already been stopped.
      // The runtime must forcibly kill the container after the grace period is
      // reached.
      virtual void StopContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopContainerRequest* request, ::runtime::v1alpha2::StopContainerResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopContainerRequest* request, ::runtime::v1alpha2::StopContainerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // RemoveContainer removes the container. If the container is running, the
      // container must be forcibly removed.
      // This call is idempotent, and must not return an error if the container has
      // already been removed.
      virtual void RemoveContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveContainerRequest* request, ::runtime::v1alpha2::RemoveContainerResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RemoveContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveContainerRequest* request, ::runtime::v1alpha2::RemoveContainerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ListContainers lists all containers by filters.
      virtual void ListContainers(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainersRequest* request, ::runtime::v1alpha2::ListContainersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListContainers(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainersRequest* request, ::runtime::v1alpha2::ListContainersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ContainerStatus returns status of the container. If the container is not
      // present, returns an error.
      virtual void ContainerStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatusRequest* request, ::runtime::v1alpha2::ContainerStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ContainerStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatusRequest* request, ::runtime::v1alpha2::ContainerStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // UpdateContainerResources updates ContainerConfig of the container synchronously.
      // If runtime fails to transactionally update the requested resources, an error is returned.
      virtual void UpdateContainerResources(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateContainerResourcesRequest* request, ::runtime::v1alpha2::UpdateContainerResourcesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateContainerResources(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateContainerResourcesRequest* request, ::runtime::v1alpha2::UpdateContainerResourcesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ReopenContainerLog asks runtime to reopen the stdout/stderr log file
      // for the container. This is often called after the log file has been
      // rotated. If the container is not running, container runtime can choose
      // to either create a new log file and return nil, or return an error.
      // Once it returns error, new container log file MUST NOT be created.
      virtual void ReopenContainerLog(::grpc::ClientContext* context, const ::runtime::v1alpha2::ReopenContainerLogRequest* request, ::runtime::v1alpha2::ReopenContainerLogResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ReopenContainerLog(::grpc::ClientContext* context, const ::runtime::v1alpha2::ReopenContainerLogRequest* request, ::runtime::v1alpha2::ReopenContainerLogResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ExecSync runs a command in a container synchronously.
      virtual void ExecSync(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecSyncRequest* request, ::runtime::v1alpha2::ExecSyncResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ExecSync(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecSyncRequest* request, ::runtime::v1alpha2::ExecSyncResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Exec prepares a streaming endpoint to execute a command in the container.
      virtual void Exec(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecRequest* request, ::runtime::v1alpha2::ExecResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Exec(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecRequest* request, ::runtime::v1alpha2::ExecResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Attach prepares a streaming endpoint to attach to a running container.
      virtual void Attach(::grpc::ClientContext* context, const ::runtime::v1alpha2::AttachRequest* request, ::runtime::v1alpha2::AttachResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Attach(::grpc::ClientContext* context, const ::runtime::v1alpha2::AttachRequest* request, ::runtime::v1alpha2::AttachResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // PortForward prepares a streaming endpoint to forward ports from a PodSandbox.
      virtual void PortForward(::grpc::ClientContext* context, const ::runtime::v1alpha2::PortForwardRequest* request, ::runtime::v1alpha2::PortForwardResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PortForward(::grpc::ClientContext* context, const ::runtime::v1alpha2::PortForwardRequest* request, ::runtime::v1alpha2::PortForwardResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ContainerStats returns stats of the container. If the container does not
      // exist, the call returns an error.
      virtual void ContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatsRequest* request, ::runtime::v1alpha2::ContainerStatsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatsRequest* request, ::runtime::v1alpha2::ContainerStatsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ListContainerStats returns stats of all running containers.
      virtual void ListContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainerStatsRequest* request, ::runtime::v1alpha2::ListContainerStatsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainerStatsRequest* request, ::runtime::v1alpha2::ListContainerStatsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // PodSandboxStats returns stats of the pod sandbox. If the pod sandbox does not
      // exist, the call returns an error.
      virtual void PodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatsRequest* request, ::runtime::v1alpha2::PodSandboxStatsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatsRequest* request, ::runtime::v1alpha2::PodSandboxStatsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ListPodSandboxStats returns stats of the pod sandboxes matching a filter.
      virtual void ListPodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxStatsRequest* request, ::runtime::v1alpha2::ListPodSandboxStatsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListPodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxStatsRequest* request, ::runtime::v1alpha2::ListPodSandboxStatsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // UpdateRuntimeConfig updates the runtime configuration based on the given request.
      virtual void UpdateRuntimeConfig(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest* request, ::runtime::v1alpha2::UpdateRuntimeConfigResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateRuntimeConfig(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest* request, ::runtime::v1alpha2::UpdateRuntimeConfigResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Status returns the status of the runtime.
      virtual void Status(::grpc::ClientContext* context, const ::runtime::v1alpha2::StatusRequest* request, ::runtime::v1alpha2::StatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Status(::grpc::ClientContext* context, const ::runtime::v1alpha2::StatusRequest* request, ::runtime::v1alpha2::StatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::VersionResponse>* AsyncVersionRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::VersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::VersionResponse>* PrepareAsyncVersionRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::VersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RunPodSandboxResponse>* AsyncRunPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::RunPodSandboxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RunPodSandboxResponse>* PrepareAsyncRunPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::RunPodSandboxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StopPodSandboxResponse>* AsyncStopPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopPodSandboxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StopPodSandboxResponse>* PrepareAsyncStopPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopPodSandboxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemovePodSandboxResponse>* AsyncRemovePodSandboxRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemovePodSandboxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemovePodSandboxResponse>* PrepareAsyncRemovePodSandboxRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemovePodSandboxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PodSandboxStatusResponse>* AsyncPodSandboxStatusRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PodSandboxStatusResponse>* PrepareAsyncPodSandboxStatusRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListPodSandboxResponse>* AsyncListPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListPodSandboxResponse>* PrepareAsyncListPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::CreateContainerResponse>* AsyncCreateContainerRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::CreateContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::CreateContainerResponse>* PrepareAsyncCreateContainerRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::CreateContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StartContainerResponse>* AsyncStartContainerRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::StartContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StartContainerResponse>* PrepareAsyncStartContainerRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::StartContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StopContainerResponse>* AsyncStopContainerRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StopContainerResponse>* PrepareAsyncStopContainerRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemoveContainerResponse>* AsyncRemoveContainerRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemoveContainerResponse>* PrepareAsyncRemoveContainerRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListContainersResponse>* AsyncListContainersRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListContainersResponse>* PrepareAsyncListContainersRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ContainerStatusResponse>* AsyncContainerStatusRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ContainerStatusResponse>* PrepareAsyncContainerStatusRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::UpdateContainerResourcesResponse>* AsyncUpdateContainerResourcesRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateContainerResourcesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::UpdateContainerResourcesResponse>* PrepareAsyncUpdateContainerResourcesRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateContainerResourcesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ReopenContainerLogResponse>* AsyncReopenContainerLogRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ReopenContainerLogRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ReopenContainerLogResponse>* PrepareAsyncReopenContainerLogRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ReopenContainerLogRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ExecSyncResponse>* AsyncExecSyncRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ExecSyncResponse>* PrepareAsyncExecSyncRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ExecResponse>* AsyncExecRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ExecResponse>* PrepareAsyncExecRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::AttachResponse>* AsyncAttachRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::AttachRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::AttachResponse>* PrepareAsyncAttachRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::AttachRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PortForwardResponse>* AsyncPortForwardRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::PortForwardRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PortForwardResponse>* PrepareAsyncPortForwardRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::PortForwardRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ContainerStatsResponse>* AsyncContainerStatsRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ContainerStatsResponse>* PrepareAsyncContainerStatsRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListContainerStatsResponse>* AsyncListContainerStatsRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainerStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListContainerStatsResponse>* PrepareAsyncListContainerStatsRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainerStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PodSandboxStatsResponse>* AsyncPodSandboxStatsRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PodSandboxStatsResponse>* PrepareAsyncPodSandboxStatsRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListPodSandboxStatsResponse>* AsyncListPodSandboxStatsRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListPodSandboxStatsResponse>* PrepareAsyncListPodSandboxStatsRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::UpdateRuntimeConfigResponse>* AsyncUpdateRuntimeConfigRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::UpdateRuntimeConfigResponse>* PrepareAsyncUpdateRuntimeConfigRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StatusResponse>* AsyncStatusRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::StatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::StatusResponse>* PrepareAsyncStatusRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::StatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Version(::grpc::ClientContext* context, const ::runtime::v1alpha2::VersionRequest& request, ::runtime::v1alpha2::VersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::VersionResponse>> AsyncVersion(::grpc::ClientContext* context, const ::runtime::v1alpha2::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::VersionResponse>>(AsyncVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::VersionResponse>> PrepareAsyncVersion(::grpc::ClientContext* context, const ::runtime::v1alpha2::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::VersionResponse>>(PrepareAsyncVersionRaw(context, request, cq));
    }
    ::grpc::Status RunPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RunPodSandboxRequest& request, ::runtime::v1alpha2::RunPodSandboxResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RunPodSandboxResponse>> AsyncRunPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RunPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RunPodSandboxResponse>>(AsyncRunPodSandboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RunPodSandboxResponse>> PrepareAsyncRunPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RunPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RunPodSandboxResponse>>(PrepareAsyncRunPodSandboxRaw(context, request, cq));
    }
    ::grpc::Status StopPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopPodSandboxRequest& request, ::runtime::v1alpha2::StopPodSandboxResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StopPodSandboxResponse>> AsyncStopPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StopPodSandboxResponse>>(AsyncStopPodSandboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StopPodSandboxResponse>> PrepareAsyncStopPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StopPodSandboxResponse>>(PrepareAsyncStopPodSandboxRaw(context, request, cq));
    }
    ::grpc::Status RemovePodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemovePodSandboxRequest& request, ::runtime::v1alpha2::RemovePodSandboxResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemovePodSandboxResponse>> AsyncRemovePodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemovePodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemovePodSandboxResponse>>(AsyncRemovePodSandboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemovePodSandboxResponse>> PrepareAsyncRemovePodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemovePodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemovePodSandboxResponse>>(PrepareAsyncRemovePodSandboxRaw(context, request, cq));
    }
    ::grpc::Status PodSandboxStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatusRequest& request, ::runtime::v1alpha2::PodSandboxStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PodSandboxStatusResponse>> AsyncPodSandboxStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PodSandboxStatusResponse>>(AsyncPodSandboxStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PodSandboxStatusResponse>> PrepareAsyncPodSandboxStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PodSandboxStatusResponse>>(PrepareAsyncPodSandboxStatusRaw(context, request, cq));
    }
    ::grpc::Status ListPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxRequest& request, ::runtime::v1alpha2::ListPodSandboxResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListPodSandboxResponse>> AsyncListPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListPodSandboxResponse>>(AsyncListPodSandboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListPodSandboxResponse>> PrepareAsyncListPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListPodSandboxResponse>>(PrepareAsyncListPodSandboxRaw(context, request, cq));
    }
    ::grpc::Status CreateContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::CreateContainerRequest& request, ::runtime::v1alpha2::CreateContainerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::CreateContainerResponse>> AsyncCreateContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::CreateContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::CreateContainerResponse>>(AsyncCreateContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::CreateContainerResponse>> PrepareAsyncCreateContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::CreateContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::CreateContainerResponse>>(PrepareAsyncCreateContainerRaw(context, request, cq));
    }
    ::grpc::Status StartContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StartContainerRequest& request, ::runtime::v1alpha2::StartContainerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StartContainerResponse>> AsyncStartContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StartContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StartContainerResponse>>(AsyncStartContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StartContainerResponse>> PrepareAsyncStartContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StartContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StartContainerResponse>>(PrepareAsyncStartContainerRaw(context, request, cq));
    }
    ::grpc::Status StopContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopContainerRequest& request, ::runtime::v1alpha2::StopContainerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StopContainerResponse>> AsyncStopContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StopContainerResponse>>(AsyncStopContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StopContainerResponse>> PrepareAsyncStopContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StopContainerResponse>>(PrepareAsyncStopContainerRaw(context, request, cq));
    }
    ::grpc::Status RemoveContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveContainerRequest& request, ::runtime::v1alpha2::RemoveContainerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemoveContainerResponse>> AsyncRemoveContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemoveContainerResponse>>(AsyncRemoveContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemoveContainerResponse>> PrepareAsyncRemoveContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemoveContainerResponse>>(PrepareAsyncRemoveContainerRaw(context, request, cq));
    }
    ::grpc::Status ListContainers(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainersRequest& request, ::runtime::v1alpha2::ListContainersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListContainersResponse>> AsyncListContainers(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListContainersResponse>>(AsyncListContainersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListContainersResponse>> PrepareAsyncListContainers(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListContainersResponse>>(PrepareAsyncListContainersRaw(context, request, cq));
    }
    ::grpc::Status ContainerStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatusRequest& request, ::runtime::v1alpha2::ContainerStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ContainerStatusResponse>> AsyncContainerStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ContainerStatusResponse>>(AsyncContainerStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ContainerStatusResponse>> PrepareAsyncContainerStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ContainerStatusResponse>>(PrepareAsyncContainerStatusRaw(context, request, cq));
    }
    ::grpc::Status UpdateContainerResources(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateContainerResourcesRequest& request, ::runtime::v1alpha2::UpdateContainerResourcesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::UpdateContainerResourcesResponse>> AsyncUpdateContainerResources(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateContainerResourcesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::UpdateContainerResourcesResponse>>(AsyncUpdateContainerResourcesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::UpdateContainerResourcesResponse>> PrepareAsyncUpdateContainerResources(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateContainerResourcesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::UpdateContainerResourcesResponse>>(PrepareAsyncUpdateContainerResourcesRaw(context, request, cq));
    }
    ::grpc::Status ReopenContainerLog(::grpc::ClientContext* context, const ::runtime::v1alpha2::ReopenContainerLogRequest& request, ::runtime::v1alpha2::ReopenContainerLogResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ReopenContainerLogResponse>> AsyncReopenContainerLog(::grpc::ClientContext* context, const ::runtime::v1alpha2::ReopenContainerLogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ReopenContainerLogResponse>>(AsyncReopenContainerLogRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ReopenContainerLogResponse>> PrepareAsyncReopenContainerLog(::grpc::ClientContext* context, const ::runtime::v1alpha2::ReopenContainerLogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ReopenContainerLogResponse>>(PrepareAsyncReopenContainerLogRaw(context, request, cq));
    }
    ::grpc::Status ExecSync(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecSyncRequest& request, ::runtime::v1alpha2::ExecSyncResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ExecSyncResponse>> AsyncExecSync(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ExecSyncResponse>>(AsyncExecSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ExecSyncResponse>> PrepareAsyncExecSync(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ExecSyncResponse>>(PrepareAsyncExecSyncRaw(context, request, cq));
    }
    ::grpc::Status Exec(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecRequest& request, ::runtime::v1alpha2::ExecResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ExecResponse>> AsyncExec(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ExecResponse>>(AsyncExecRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ExecResponse>> PrepareAsyncExec(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ExecResponse>>(PrepareAsyncExecRaw(context, request, cq));
    }
    ::grpc::Status Attach(::grpc::ClientContext* context, const ::runtime::v1alpha2::AttachRequest& request, ::runtime::v1alpha2::AttachResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::AttachResponse>> AsyncAttach(::grpc::ClientContext* context, const ::runtime::v1alpha2::AttachRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::AttachResponse>>(AsyncAttachRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::AttachResponse>> PrepareAsyncAttach(::grpc::ClientContext* context, const ::runtime::v1alpha2::AttachRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::AttachResponse>>(PrepareAsyncAttachRaw(context, request, cq));
    }
    ::grpc::Status PortForward(::grpc::ClientContext* context, const ::runtime::v1alpha2::PortForwardRequest& request, ::runtime::v1alpha2::PortForwardResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PortForwardResponse>> AsyncPortForward(::grpc::ClientContext* context, const ::runtime::v1alpha2::PortForwardRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PortForwardResponse>>(AsyncPortForwardRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PortForwardResponse>> PrepareAsyncPortForward(::grpc::ClientContext* context, const ::runtime::v1alpha2::PortForwardRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PortForwardResponse>>(PrepareAsyncPortForwardRaw(context, request, cq));
    }
    ::grpc::Status ContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatsRequest& request, ::runtime::v1alpha2::ContainerStatsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ContainerStatsResponse>> AsyncContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ContainerStatsResponse>>(AsyncContainerStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ContainerStatsResponse>> PrepareAsyncContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ContainerStatsResponse>>(PrepareAsyncContainerStatsRaw(context, request, cq));
    }
    ::grpc::Status ListContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainerStatsRequest& request, ::runtime::v1alpha2::ListContainerStatsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListContainerStatsResponse>> AsyncListContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainerStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListContainerStatsResponse>>(AsyncListContainerStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListContainerStatsResponse>> PrepareAsyncListContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainerStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListContainerStatsResponse>>(PrepareAsyncListContainerStatsRaw(context, request, cq));
    }
    ::grpc::Status PodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatsRequest& request, ::runtime::v1alpha2::PodSandboxStatsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PodSandboxStatsResponse>> AsyncPodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PodSandboxStatsResponse>>(AsyncPodSandboxStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PodSandboxStatsResponse>> PrepareAsyncPodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PodSandboxStatsResponse>>(PrepareAsyncPodSandboxStatsRaw(context, request, cq));
    }
    ::grpc::Status ListPodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxStatsRequest& request, ::runtime::v1alpha2::ListPodSandboxStatsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListPodSandboxStatsResponse>> AsyncListPodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListPodSandboxStatsResponse>>(AsyncListPodSandboxStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListPodSandboxStatsResponse>> PrepareAsyncListPodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListPodSandboxStatsResponse>>(PrepareAsyncListPodSandboxStatsRaw(context, request, cq));
    }
    ::grpc::Status UpdateRuntimeConfig(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest& request, ::runtime::v1alpha2::UpdateRuntimeConfigResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::UpdateRuntimeConfigResponse>> AsyncUpdateRuntimeConfig(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::UpdateRuntimeConfigResponse>>(AsyncUpdateRuntimeConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::UpdateRuntimeConfigResponse>> PrepareAsyncUpdateRuntimeConfig(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::UpdateRuntimeConfigResponse>>(PrepareAsyncUpdateRuntimeConfigRaw(context, request, cq));
    }
    ::grpc::Status Status(::grpc::ClientContext* context, const ::runtime::v1alpha2::StatusRequest& request, ::runtime::v1alpha2::StatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StatusResponse>> AsyncStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::StatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StatusResponse>>(AsyncStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StatusResponse>> PrepareAsyncStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::StatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StatusResponse>>(PrepareAsyncStatusRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Version(::grpc::ClientContext* context, const ::runtime::v1alpha2::VersionRequest* request, ::runtime::v1alpha2::VersionResponse* response, std::function<void(::grpc::Status)>) override;
      void Version(::grpc::ClientContext* context, const ::runtime::v1alpha2::VersionRequest* request, ::runtime::v1alpha2::VersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RunPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RunPodSandboxRequest* request, ::runtime::v1alpha2::RunPodSandboxResponse* response, std::function<void(::grpc::Status)>) override;
      void RunPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RunPodSandboxRequest* request, ::runtime::v1alpha2::RunPodSandboxResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StopPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopPodSandboxRequest* request, ::runtime::v1alpha2::StopPodSandboxResponse* response, std::function<void(::grpc::Status)>) override;
      void StopPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopPodSandboxRequest* request, ::runtime::v1alpha2::StopPodSandboxResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RemovePodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemovePodSandboxRequest* request, ::runtime::v1alpha2::RemovePodSandboxResponse* response, std::function<void(::grpc::Status)>) override;
      void RemovePodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemovePodSandboxRequest* request, ::runtime::v1alpha2::RemovePodSandboxResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PodSandboxStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatusRequest* request, ::runtime::v1alpha2::PodSandboxStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void PodSandboxStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatusRequest* request, ::runtime::v1alpha2::PodSandboxStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxRequest* request, ::runtime::v1alpha2::ListPodSandboxResponse* response, std::function<void(::grpc::Status)>) override;
      void ListPodSandbox(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxRequest* request, ::runtime::v1alpha2::ListPodSandboxResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreateContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::CreateContainerRequest* request, ::runtime::v1alpha2::CreateContainerResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::CreateContainerRequest* request, ::runtime::v1alpha2::CreateContainerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StartContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StartContainerRequest* request, ::runtime::v1alpha2::StartContainerResponse* response, std::function<void(::grpc::Status)>) override;
      void StartContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StartContainerRequest* request, ::runtime::v1alpha2::StartContainerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StopContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopContainerRequest* request, ::runtime::v1alpha2::StopContainerResponse* response, std::function<void(::grpc::Status)>) override;
      void StopContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopContainerRequest* request, ::runtime::v1alpha2::StopContainerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RemoveContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveContainerRequest* request, ::runtime::v1alpha2::RemoveContainerResponse* response, std::function<void(::grpc::Status)>) override;
      void RemoveContainer(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveContainerRequest* request, ::runtime::v1alpha2::RemoveContainerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListContainers(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainersRequest* request, ::runtime::v1alpha2::ListContainersResponse* response, std::function<void(::grpc::Status)>) override;
      void ListContainers(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainersRequest* request, ::runtime::v1alpha2::ListContainersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ContainerStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatusRequest* request, ::runtime::v1alpha2::ContainerStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void ContainerStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatusRequest* request, ::runtime::v1alpha2::ContainerStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateContainerResources(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateContainerResourcesRequest* request, ::runtime::v1alpha2::UpdateContainerResourcesResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateContainerResources(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateContainerResourcesRequest* request, ::runtime::v1alpha2::UpdateContainerResourcesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ReopenContainerLog(::grpc::ClientContext* context, const ::runtime::v1alpha2::ReopenContainerLogRequest* request, ::runtime::v1alpha2::ReopenContainerLogResponse* response, std::function<void(::grpc::Status)>) override;
      void ReopenContainerLog(::grpc::ClientContext* context, const ::runtime::v1alpha2::ReopenContainerLogRequest* request, ::runtime::v1alpha2::ReopenContainerLogResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ExecSync(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecSyncRequest* request, ::runtime::v1alpha2::ExecSyncResponse* response, std::function<void(::grpc::Status)>) override;
      void ExecSync(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecSyncRequest* request, ::runtime::v1alpha2::ExecSyncResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Exec(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecRequest* request, ::runtime::v1alpha2::ExecResponse* response, std::function<void(::grpc::Status)>) override;
      void Exec(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecRequest* request, ::runtime::v1alpha2::ExecResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Attach(::grpc::ClientContext* context, const ::runtime::v1alpha2::AttachRequest* request, ::runtime::v1alpha2::AttachResponse* response, std::function<void(::grpc::Status)>) override;
      void Attach(::grpc::ClientContext* context, const ::runtime::v1alpha2::AttachRequest* request, ::runtime::v1alpha2::AttachResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PortForward(::grpc::ClientContext* context, const ::runtime::v1alpha2::PortForwardRequest* request, ::runtime::v1alpha2::PortForwardResponse* response, std::function<void(::grpc::Status)>) override;
      void PortForward(::grpc::ClientContext* context, const ::runtime::v1alpha2::PortForwardRequest* request, ::runtime::v1alpha2::PortForwardResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatsRequest* request, ::runtime::v1alpha2::ContainerStatsResponse* response, std::function<void(::grpc::Status)>) override;
      void ContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatsRequest* request, ::runtime::v1alpha2::ContainerStatsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainerStatsRequest* request, ::runtime::v1alpha2::ListContainerStatsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListContainerStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainerStatsRequest* request, ::runtime::v1alpha2::ListContainerStatsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatsRequest* request, ::runtime::v1alpha2::PodSandboxStatsResponse* response, std::function<void(::grpc::Status)>) override;
      void PodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatsRequest* request, ::runtime::v1alpha2::PodSandboxStatsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListPodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxStatsRequest* request, ::runtime::v1alpha2::ListPodSandboxStatsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListPodSandboxStats(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxStatsRequest* request, ::runtime::v1alpha2::ListPodSandboxStatsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateRuntimeConfig(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest* request, ::runtime::v1alpha2::UpdateRuntimeConfigResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateRuntimeConfig(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest* request, ::runtime::v1alpha2::UpdateRuntimeConfigResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Status(::grpc::ClientContext* context, const ::runtime::v1alpha2::StatusRequest* request, ::runtime::v1alpha2::StatusResponse* response, std::function<void(::grpc::Status)>) override;
      void Status(::grpc::ClientContext* context, const ::runtime::v1alpha2::StatusRequest* request, ::runtime::v1alpha2::StatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::VersionResponse>* AsyncVersionRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::VersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::VersionResponse>* PrepareAsyncVersionRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::VersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RunPodSandboxResponse>* AsyncRunPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::RunPodSandboxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RunPodSandboxResponse>* PrepareAsyncRunPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::RunPodSandboxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StopPodSandboxResponse>* AsyncStopPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopPodSandboxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StopPodSandboxResponse>* PrepareAsyncStopPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopPodSandboxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemovePodSandboxResponse>* AsyncRemovePodSandboxRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemovePodSandboxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemovePodSandboxResponse>* PrepareAsyncRemovePodSandboxRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemovePodSandboxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PodSandboxStatusResponse>* AsyncPodSandboxStatusRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PodSandboxStatusResponse>* PrepareAsyncPodSandboxStatusRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListPodSandboxResponse>* AsyncListPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListPodSandboxResponse>* PrepareAsyncListPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::CreateContainerResponse>* AsyncCreateContainerRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::CreateContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::CreateContainerResponse>* PrepareAsyncCreateContainerRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::CreateContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StartContainerResponse>* AsyncStartContainerRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::StartContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StartContainerResponse>* PrepareAsyncStartContainerRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::StartContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StopContainerResponse>* AsyncStopContainerRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StopContainerResponse>* PrepareAsyncStopContainerRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::StopContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemoveContainerResponse>* AsyncRemoveContainerRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemoveContainerResponse>* PrepareAsyncRemoveContainerRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListContainersResponse>* AsyncListContainersRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListContainersResponse>* PrepareAsyncListContainersRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ContainerStatusResponse>* AsyncContainerStatusRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ContainerStatusResponse>* PrepareAsyncContainerStatusRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::UpdateContainerResourcesResponse>* AsyncUpdateContainerResourcesRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateContainerResourcesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::UpdateContainerResourcesResponse>* PrepareAsyncUpdateContainerResourcesRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateContainerResourcesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ReopenContainerLogResponse>* AsyncReopenContainerLogRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ReopenContainerLogRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ReopenContainerLogResponse>* PrepareAsyncReopenContainerLogRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ReopenContainerLogRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ExecSyncResponse>* AsyncExecSyncRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ExecSyncResponse>* PrepareAsyncExecSyncRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ExecResponse>* AsyncExecRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ExecResponse>* PrepareAsyncExecRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ExecRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::AttachResponse>* AsyncAttachRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::AttachRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::AttachResponse>* PrepareAsyncAttachRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::AttachRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PortForwardResponse>* AsyncPortForwardRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::PortForwardRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PortForwardResponse>* PrepareAsyncPortForwardRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::PortForwardRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ContainerStatsResponse>* AsyncContainerStatsRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ContainerStatsResponse>* PrepareAsyncContainerStatsRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ContainerStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListContainerStatsResponse>* AsyncListContainerStatsRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainerStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListContainerStatsResponse>* PrepareAsyncListContainerStatsRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListContainerStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PodSandboxStatsResponse>* AsyncPodSandboxStatsRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PodSandboxStatsResponse>* PrepareAsyncPodSandboxStatsRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::PodSandboxStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListPodSandboxStatsResponse>* AsyncListPodSandboxStatsRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListPodSandboxStatsResponse>* PrepareAsyncListPodSandboxStatsRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListPodSandboxStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::UpdateRuntimeConfigResponse>* AsyncUpdateRuntimeConfigRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::UpdateRuntimeConfigResponse>* PrepareAsyncUpdateRuntimeConfigRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StatusResponse>* AsyncStatusRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::StatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::StatusResponse>* PrepareAsyncStatusRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::StatusRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Version_;
    const ::grpc::internal::RpcMethod rpcmethod_RunPodSandbox_;
    const ::grpc::internal::RpcMethod rpcmethod_StopPodSandbox_;
    const ::grpc::internal::RpcMethod rpcmethod_RemovePodSandbox_;
    const ::grpc::internal::RpcMethod rpcmethod_PodSandboxStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_ListPodSandbox_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateContainer_;
    const ::grpc::internal::RpcMethod rpcmethod_StartContainer_;
    const ::grpc::internal::RpcMethod rpcmethod_StopContainer_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveContainer_;
    const ::grpc::internal::RpcMethod rpcmethod_ListContainers_;
    const ::grpc::internal::RpcMethod rpcmethod_ContainerStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateContainerResources_;
    const ::grpc::internal::RpcMethod rpcmethod_ReopenContainerLog_;
    const ::grpc::internal::RpcMethod rpcmethod_ExecSync_;
    const ::grpc::internal::RpcMethod rpcmethod_Exec_;
    const ::grpc::internal::RpcMethod rpcmethod_Attach_;
    const ::grpc::internal::RpcMethod rpcmethod_PortForward_;
    const ::grpc::internal::RpcMethod rpcmethod_ContainerStats_;
    const ::grpc::internal::RpcMethod rpcmethod_ListContainerStats_;
    const ::grpc::internal::RpcMethod rpcmethod_PodSandboxStats_;
    const ::grpc::internal::RpcMethod rpcmethod_ListPodSandboxStats_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateRuntimeConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_Status_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Version returns the runtime name, runtime version, and runtime API version.
    virtual ::grpc::Status Version(::grpc::ServerContext* context, const ::runtime::v1alpha2::VersionRequest* request, ::runtime::v1alpha2::VersionResponse* response);
    // RunPodSandbox creates and starts a pod-level sandbox. Runtimes must ensure
    // the sandbox is in the ready state on success.
    virtual ::grpc::Status RunPodSandbox(::grpc::ServerContext* context, const ::runtime::v1alpha2::RunPodSandboxRequest* request, ::runtime::v1alpha2::RunPodSandboxResponse* response);
    // StopPodSandbox stops any running process that is part of the sandbox and
    // reclaims network resources (e.g., IP addresses) allocated to the sandbox.
    // If there are any running containers in the sandbox, they must be forcibly
    // terminated.
    // This call is idempotent, and must not return an error if all relevant
    // resources have already been reclaimed. kubelet will call StopPodSandbox
    // at least once before calling RemovePodSandbox. It will also attempt to
    // reclaim resources eagerly, as soon as a sandbox is not needed. Hence,
    // multiple StopPodSandbox calls are expected.
    virtual ::grpc::Status StopPodSandbox(::grpc::ServerContext* context, const ::runtime::v1alpha2::StopPodSandboxRequest* request, ::runtime::v1alpha2::StopPodSandboxResponse* response);
    // RemovePodSandbox removes the sandbox. If there are any running containers
    // in the sandbox, they must be forcibly terminated and removed.
    // This call is idempotent, and must not return an error if the sandbox has
    // already been removed.
    virtual ::grpc::Status RemovePodSandbox(::grpc::ServerContext* context, const ::runtime::v1alpha2::RemovePodSandboxRequest* request, ::runtime::v1alpha2::RemovePodSandboxResponse* response);
    // PodSandboxStatus returns the status of the PodSandbox. If the PodSandbox is not
    // present, returns an error.
    virtual ::grpc::Status PodSandboxStatus(::grpc::ServerContext* context, const ::runtime::v1alpha2::PodSandboxStatusRequest* request, ::runtime::v1alpha2::PodSandboxStatusResponse* response);
    // ListPodSandbox returns a list of PodSandboxes.
    virtual ::grpc::Status ListPodSandbox(::grpc::ServerContext* context, const ::runtime::v1alpha2::ListPodSandboxRequest* request, ::runtime::v1alpha2::ListPodSandboxResponse* response);
    // CreateContainer creates a new container in specified PodSandbox
    virtual ::grpc::Status CreateContainer(::grpc::ServerContext* context, const ::runtime::v1alpha2::CreateContainerRequest* request, ::runtime::v1alpha2::CreateContainerResponse* response);
    // StartContainer starts the container.
    virtual ::grpc::Status StartContainer(::grpc::ServerContext* context, const ::runtime::v1alpha2::StartContainerRequest* request, ::runtime::v1alpha2::StartContainerResponse* response);
    // StopContainer stops a running container with a grace period (i.e., timeout).
    // This call is idempotent, and must not return an error if the container has
    // already been stopped.
    // The runtime must forcibly kill the container after the grace period is
    // reached.
    virtual ::grpc::Status StopContainer(::grpc::ServerContext* context, const ::runtime::v1alpha2::StopContainerRequest* request, ::runtime::v1alpha2::StopContainerResponse* response);
    // RemoveContainer removes the container. If the container is running, the
    // container must be forcibly removed.
    // This call is idempotent, and must not return an error if the container has
    // already been removed.
    virtual ::grpc::Status RemoveContainer(::grpc::ServerContext* context, const ::runtime::v1alpha2::RemoveContainerRequest* request, ::runtime::v1alpha2::RemoveContainerResponse* response);
    // ListContainers lists all containers by filters.
    virtual ::grpc::Status ListContainers(::grpc::ServerContext* context, const ::runtime::v1alpha2::ListContainersRequest* request, ::runtime::v1alpha2::ListContainersResponse* response);
    // ContainerStatus returns status of the container. If the container is not
    // present, returns an error.
    virtual ::grpc::Status ContainerStatus(::grpc::ServerContext* context, const ::runtime::v1alpha2::ContainerStatusRequest* request, ::runtime::v1alpha2::ContainerStatusResponse* response);
    // UpdateContainerResources updates ContainerConfig of the container synchronously.
    // If runtime fails to transactionally update the requested resources, an error is returned.
    virtual ::grpc::Status UpdateContainerResources(::grpc::ServerContext* context, const ::runtime::v1alpha2::UpdateContainerResourcesRequest* request, ::runtime::v1alpha2::UpdateContainerResourcesResponse* response);
    // ReopenContainerLog asks runtime to reopen the stdout/stderr log file
    // for the container. This is often called after the log file has been
    // rotated. If the container is not running, container runtime can choose
    // to either create a new log file and return nil, or return an error.
    // Once it returns error, new container log file MUST NOT be created.
    virtual ::grpc::Status ReopenContainerLog(::grpc::ServerContext* context, const ::runtime::v1alpha2::ReopenContainerLogRequest* request, ::runtime::v1alpha2::ReopenContainerLogResponse* response);
    // ExecSync runs a command in a container synchronously.
    virtual ::grpc::Status ExecSync(::grpc::ServerContext* context, const ::runtime::v1alpha2::ExecSyncRequest* request, ::runtime::v1alpha2::ExecSyncResponse* response);
    // Exec prepares a streaming endpoint to execute a command in the container.
    virtual ::grpc::Status Exec(::grpc::ServerContext* context, const ::runtime::v1alpha2::ExecRequest* request, ::runtime::v1alpha2::ExecResponse* response);
    // Attach prepares a streaming endpoint to attach to a running container.
    virtual ::grpc::Status Attach(::grpc::ServerContext* context, const ::runtime::v1alpha2::AttachRequest* request, ::runtime::v1alpha2::AttachResponse* response);
    // PortForward prepares a streaming endpoint to forward ports from a PodSandbox.
    virtual ::grpc::Status PortForward(::grpc::ServerContext* context, const ::runtime::v1alpha2::PortForwardRequest* request, ::runtime::v1alpha2::PortForwardResponse* response);
    // ContainerStats returns stats of the container. If the container does not
    // exist, the call returns an error.
    virtual ::grpc::Status ContainerStats(::grpc::ServerContext* context, const ::runtime::v1alpha2::ContainerStatsRequest* request, ::runtime::v1alpha2::ContainerStatsResponse* response);
    // ListContainerStats returns stats of all running containers.
    virtual ::grpc::Status ListContainerStats(::grpc::ServerContext* context, const ::runtime::v1alpha2::ListContainerStatsRequest* request, ::runtime::v1alpha2::ListContainerStatsResponse* response);
    // PodSandboxStats returns stats of the pod sandbox. If the pod sandbox does not
    // exist, the call returns an error.
    virtual ::grpc::Status PodSandboxStats(::grpc::ServerContext* context, const ::runtime::v1alpha2::PodSandboxStatsRequest* request, ::runtime::v1alpha2::PodSandboxStatsResponse* response);
    // ListPodSandboxStats returns stats of the pod sandboxes matching a filter.
    virtual ::grpc::Status ListPodSandboxStats(::grpc::ServerContext* context, const ::runtime::v1alpha2::ListPodSandboxStatsRequest* request, ::runtime::v1alpha2::ListPodSandboxStatsResponse* response);
    // UpdateRuntimeConfig updates the runtime configuration based on the given request.
    virtual ::grpc::Status UpdateRuntimeConfig(::grpc::ServerContext* context, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest* request, ::runtime::v1alpha2::UpdateRuntimeConfigResponse* response);
    // Status returns the status of the runtime.
    virtual ::grpc::Status Status(::grpc::ServerContext* context, const ::runtime::v1alpha2::StatusRequest* request, ::runtime::v1alpha2::StatusResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Version() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::VersionRequest* /*request*/, ::runtime::v1alpha2::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVersion(::grpc::ServerContext* context, ::runtime::v1alpha2::VersionRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::VersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RunPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RunPodSandbox() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_RunPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RunPodSandboxRequest* /*request*/, ::runtime::v1alpha2::RunPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunPodSandbox(::grpc::ServerContext* context, ::runtime::v1alpha2::RunPodSandboxRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::RunPodSandboxResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopPodSandbox() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_StopPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StopPodSandboxRequest* /*request*/, ::runtime::v1alpha2::StopPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopPodSandbox(::grpc::ServerContext* context, ::runtime::v1alpha2::StopPodSandboxRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::StopPodSandboxResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemovePodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemovePodSandbox() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_RemovePodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemovePodSandboxRequest* /*request*/, ::runtime::v1alpha2::RemovePodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemovePodSandbox(::grpc::ServerContext* context, ::runtime::v1alpha2::RemovePodSandboxRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::RemovePodSandboxResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PodSandboxStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PodSandboxStatus() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_PodSandboxStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PodSandboxStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PodSandboxStatusRequest* /*request*/, ::runtime::v1alpha2::PodSandboxStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPodSandboxStatus(::grpc::ServerContext* context, ::runtime::v1alpha2::PodSandboxStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::PodSandboxStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListPodSandbox() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ListPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListPodSandboxRequest* /*request*/, ::runtime::v1alpha2::ListPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListPodSandbox(::grpc::ServerContext* context, ::runtime::v1alpha2::ListPodSandboxRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::ListPodSandboxResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateContainer() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::CreateContainerRequest* /*request*/, ::runtime::v1alpha2::CreateContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateContainer(::grpc::ServerContext* context, ::runtime::v1alpha2::CreateContainerRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::CreateContainerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartContainer() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_StartContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StartContainerRequest* /*request*/, ::runtime::v1alpha2::StartContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartContainer(::grpc::ServerContext* context, ::runtime::v1alpha2::StartContainerRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::StartContainerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopContainer() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_StopContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StopContainerRequest* /*request*/, ::runtime::v1alpha2::StopContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopContainer(::grpc::ServerContext* context, ::runtime::v1alpha2::StopContainerRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::StopContainerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemoveContainer() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_RemoveContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemoveContainerRequest* /*request*/, ::runtime::v1alpha2::RemoveContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveContainer(::grpc::ServerContext* context, ::runtime::v1alpha2::RemoveContainerRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::RemoveContainerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListContainers() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_ListContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListContainers(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListContainersRequest* /*request*/, ::runtime::v1alpha2::ListContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListContainers(::grpc::ServerContext* context, ::runtime::v1alpha2::ListContainersRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::ListContainersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ContainerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ContainerStatus() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_ContainerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContainerStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ContainerStatusRequest* /*request*/, ::runtime::v1alpha2::ContainerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestContainerStatus(::grpc::ServerContext* context, ::runtime::v1alpha2::ContainerStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::ContainerStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateContainerResources : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateContainerResources() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_UpdateContainerResources() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateContainerResources(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::UpdateContainerResourcesRequest* /*request*/, ::runtime::v1alpha2::UpdateContainerResourcesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateContainerResources(::grpc::ServerContext* context, ::runtime::v1alpha2::UpdateContainerResourcesRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::UpdateContainerResourcesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReopenContainerLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReopenContainerLog() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_ReopenContainerLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReopenContainerLog(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ReopenContainerLogRequest* /*request*/, ::runtime::v1alpha2::ReopenContainerLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReopenContainerLog(::grpc::ServerContext* context, ::runtime::v1alpha2::ReopenContainerLogRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::ReopenContainerLogResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExecSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExecSync() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_ExecSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecSync(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ExecSyncRequest* /*request*/, ::runtime::v1alpha2::ExecSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecSync(::grpc::ServerContext* context, ::runtime::v1alpha2::ExecSyncRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::ExecSyncResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Exec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Exec() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_Exec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Exec(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ExecRequest* /*request*/, ::runtime::v1alpha2::ExecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExec(::grpc::ServerContext* context, ::runtime::v1alpha2::ExecRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::ExecResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Attach : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Attach() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_Attach() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Attach(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::AttachRequest* /*request*/, ::runtime::v1alpha2::AttachResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAttach(::grpc::ServerContext* context, ::runtime::v1alpha2::AttachRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::AttachResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PortForward : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PortForward() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_PortForward() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortForward(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PortForwardRequest* /*request*/, ::runtime::v1alpha2::PortForwardResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPortForward(::grpc::ServerContext* context, ::runtime::v1alpha2::PortForwardRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::PortForwardResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ContainerStats() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_ContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContainerStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ContainerStatsRequest* /*request*/, ::runtime::v1alpha2::ContainerStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestContainerStats(::grpc::ServerContext* context, ::runtime::v1alpha2::ContainerStatsRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::ContainerStatsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListContainerStats() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_ListContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListContainerStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListContainerStatsRequest* /*request*/, ::runtime::v1alpha2::ListContainerStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListContainerStats(::grpc::ServerContext* context, ::runtime::v1alpha2::ListContainerStatsRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::ListContainerStatsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PodSandboxStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PodSandboxStats() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_PodSandboxStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PodSandboxStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PodSandboxStatsRequest* /*request*/, ::runtime::v1alpha2::PodSandboxStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPodSandboxStats(::grpc::ServerContext* context, ::runtime::v1alpha2::PodSandboxStatsRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::PodSandboxStatsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListPodSandboxStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListPodSandboxStats() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_ListPodSandboxStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPodSandboxStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListPodSandboxStatsRequest* /*request*/, ::runtime::v1alpha2::ListPodSandboxStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListPodSandboxStats(::grpc::ServerContext* context, ::runtime::v1alpha2::ListPodSandboxStatsRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::ListPodSandboxStatsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateRuntimeConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateRuntimeConfig() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_UpdateRuntimeConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateRuntimeConfig(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest* /*request*/, ::runtime::v1alpha2::UpdateRuntimeConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateRuntimeConfig(::grpc::ServerContext* context, ::runtime::v1alpha2::UpdateRuntimeConfigRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::UpdateRuntimeConfigResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Status() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_Status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Status(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StatusRequest* /*request*/, ::runtime::v1alpha2::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStatus(::grpc::ServerContext* context, ::runtime::v1alpha2::StatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::StatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Version<WithAsyncMethod_RunPodSandbox<WithAsyncMethod_StopPodSandbox<WithAsyncMethod_RemovePodSandbox<WithAsyncMethod_PodSandboxStatus<WithAsyncMethod_ListPodSandbox<WithAsyncMethod_CreateContainer<WithAsyncMethod_StartContainer<WithAsyncMethod_StopContainer<WithAsyncMethod_RemoveContainer<WithAsyncMethod_ListContainers<WithAsyncMethod_ContainerStatus<WithAsyncMethod_UpdateContainerResources<WithAsyncMethod_ReopenContainerLog<WithAsyncMethod_ExecSync<WithAsyncMethod_Exec<WithAsyncMethod_Attach<WithAsyncMethod_PortForward<WithAsyncMethod_ContainerStats<WithAsyncMethod_ListContainerStats<WithAsyncMethod_PodSandboxStats<WithAsyncMethod_ListPodSandboxStats<WithAsyncMethod_UpdateRuntimeConfig<WithAsyncMethod_Status<Service > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Version() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::VersionRequest, ::runtime::v1alpha2::VersionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::VersionRequest* request, ::runtime::v1alpha2::VersionResponse* response) { return this->Version(context, request, response); }));}
    void SetMessageAllocatorFor_Version(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::VersionRequest, ::runtime::v1alpha2::VersionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::VersionRequest, ::runtime::v1alpha2::VersionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::VersionRequest* /*request*/, ::runtime::v1alpha2::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Version(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::VersionRequest* /*request*/, ::runtime::v1alpha2::VersionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RunPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RunPodSandbox() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::RunPodSandboxRequest, ::runtime::v1alpha2::RunPodSandboxResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::RunPodSandboxRequest* request, ::runtime::v1alpha2::RunPodSandboxResponse* response) { return this->RunPodSandbox(context, request, response); }));}
    void SetMessageAllocatorFor_RunPodSandbox(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::RunPodSandboxRequest, ::runtime::v1alpha2::RunPodSandboxResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::RunPodSandboxRequest, ::runtime::v1alpha2::RunPodSandboxResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RunPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RunPodSandboxRequest* /*request*/, ::runtime::v1alpha2::RunPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RunPodSandbox(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::RunPodSandboxRequest* /*request*/, ::runtime::v1alpha2::RunPodSandboxResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StopPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StopPodSandbox() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::StopPodSandboxRequest, ::runtime::v1alpha2::StopPodSandboxResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::StopPodSandboxRequest* request, ::runtime::v1alpha2::StopPodSandboxResponse* response) { return this->StopPodSandbox(context, request, response); }));}
    void SetMessageAllocatorFor_StopPodSandbox(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::StopPodSandboxRequest, ::runtime::v1alpha2::StopPodSandboxResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::StopPodSandboxRequest, ::runtime::v1alpha2::StopPodSandboxResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StopPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StopPodSandboxRequest* /*request*/, ::runtime::v1alpha2::StopPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopPodSandbox(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::StopPodSandboxRequest* /*request*/, ::runtime::v1alpha2::StopPodSandboxResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RemovePodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RemovePodSandbox() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::RemovePodSandboxRequest, ::runtime::v1alpha2::RemovePodSandboxResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::RemovePodSandboxRequest* request, ::runtime::v1alpha2::RemovePodSandboxResponse* response) { return this->RemovePodSandbox(context, request, response); }));}
    void SetMessageAllocatorFor_RemovePodSandbox(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::RemovePodSandboxRequest, ::runtime::v1alpha2::RemovePodSandboxResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::RemovePodSandboxRequest, ::runtime::v1alpha2::RemovePodSandboxResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RemovePodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemovePodSandboxRequest* /*request*/, ::runtime::v1alpha2::RemovePodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemovePodSandbox(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::RemovePodSandboxRequest* /*request*/, ::runtime::v1alpha2::RemovePodSandboxResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PodSandboxStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PodSandboxStatus() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::PodSandboxStatusRequest, ::runtime::v1alpha2::PodSandboxStatusResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::PodSandboxStatusRequest* request, ::runtime::v1alpha2::PodSandboxStatusResponse* response) { return this->PodSandboxStatus(context, request, response); }));}
    void SetMessageAllocatorFor_PodSandboxStatus(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::PodSandboxStatusRequest, ::runtime::v1alpha2::PodSandboxStatusResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::PodSandboxStatusRequest, ::runtime::v1alpha2::PodSandboxStatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PodSandboxStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PodSandboxStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PodSandboxStatusRequest* /*request*/, ::runtime::v1alpha2::PodSandboxStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PodSandboxStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::PodSandboxStatusRequest* /*request*/, ::runtime::v1alpha2::PodSandboxStatusResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListPodSandbox() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ListPodSandboxRequest, ::runtime::v1alpha2::ListPodSandboxResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::ListPodSandboxRequest* request, ::runtime::v1alpha2::ListPodSandboxResponse* response) { return this->ListPodSandbox(context, request, response); }));}
    void SetMessageAllocatorFor_ListPodSandbox(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::ListPodSandboxRequest, ::runtime::v1alpha2::ListPodSandboxResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ListPodSandboxRequest, ::runtime::v1alpha2::ListPodSandboxResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListPodSandboxRequest* /*request*/, ::runtime::v1alpha2::ListPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListPodSandbox(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::ListPodSandboxRequest* /*request*/, ::runtime::v1alpha2::ListPodSandboxResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateContainer() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::CreateContainerRequest, ::runtime::v1alpha2::CreateContainerResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::CreateContainerRequest* request, ::runtime::v1alpha2::CreateContainerResponse* response) { return this->CreateContainer(context, request, response); }));}
    void SetMessageAllocatorFor_CreateContainer(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::CreateContainerRequest, ::runtime::v1alpha2::CreateContainerResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::CreateContainerRequest, ::runtime::v1alpha2::CreateContainerResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::CreateContainerRequest* /*request*/, ::runtime::v1alpha2::CreateContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateContainer(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::CreateContainerRequest* /*request*/, ::runtime::v1alpha2::CreateContainerResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StartContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StartContainer() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::StartContainerRequest, ::runtime::v1alpha2::StartContainerResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::StartContainerRequest* request, ::runtime::v1alpha2::StartContainerResponse* response) { return this->StartContainer(context, request, response); }));}
    void SetMessageAllocatorFor_StartContainer(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::StartContainerRequest, ::runtime::v1alpha2::StartContainerResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::StartContainerRequest, ::runtime::v1alpha2::StartContainerResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StartContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StartContainerRequest* /*request*/, ::runtime::v1alpha2::StartContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartContainer(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::StartContainerRequest* /*request*/, ::runtime::v1alpha2::StartContainerResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StopContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StopContainer() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::StopContainerRequest, ::runtime::v1alpha2::StopContainerResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::StopContainerRequest* request, ::runtime::v1alpha2::StopContainerResponse* response) { return this->StopContainer(context, request, response); }));}
    void SetMessageAllocatorFor_StopContainer(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::StopContainerRequest, ::runtime::v1alpha2::StopContainerResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::StopContainerRequest, ::runtime::v1alpha2::StopContainerResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StopContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StopContainerRequest* /*request*/, ::runtime::v1alpha2::StopContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopContainer(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::StopContainerRequest* /*request*/, ::runtime::v1alpha2::StopContainerResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RemoveContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RemoveContainer() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::RemoveContainerRequest, ::runtime::v1alpha2::RemoveContainerResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::RemoveContainerRequest* request, ::runtime::v1alpha2::RemoveContainerResponse* response) { return this->RemoveContainer(context, request, response); }));}
    void SetMessageAllocatorFor_RemoveContainer(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::RemoveContainerRequest, ::runtime::v1alpha2::RemoveContainerResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::RemoveContainerRequest, ::runtime::v1alpha2::RemoveContainerResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RemoveContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemoveContainerRequest* /*request*/, ::runtime::v1alpha2::RemoveContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemoveContainer(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::RemoveContainerRequest* /*request*/, ::runtime::v1alpha2::RemoveContainerResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListContainers() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ListContainersRequest, ::runtime::v1alpha2::ListContainersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::ListContainersRequest* request, ::runtime::v1alpha2::ListContainersResponse* response) { return this->ListContainers(context, request, response); }));}
    void SetMessageAllocatorFor_ListContainers(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::ListContainersRequest, ::runtime::v1alpha2::ListContainersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ListContainersRequest, ::runtime::v1alpha2::ListContainersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListContainers(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListContainersRequest* /*request*/, ::runtime::v1alpha2::ListContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListContainers(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::ListContainersRequest* /*request*/, ::runtime::v1alpha2::ListContainersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ContainerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ContainerStatus() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ContainerStatusRequest, ::runtime::v1alpha2::ContainerStatusResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::ContainerStatusRequest* request, ::runtime::v1alpha2::ContainerStatusResponse* response) { return this->ContainerStatus(context, request, response); }));}
    void SetMessageAllocatorFor_ContainerStatus(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::ContainerStatusRequest, ::runtime::v1alpha2::ContainerStatusResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ContainerStatusRequest, ::runtime::v1alpha2::ContainerStatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ContainerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContainerStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ContainerStatusRequest* /*request*/, ::runtime::v1alpha2::ContainerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ContainerStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::ContainerStatusRequest* /*request*/, ::runtime::v1alpha2::ContainerStatusResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateContainerResources : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateContainerResources() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::UpdateContainerResourcesRequest, ::runtime::v1alpha2::UpdateContainerResourcesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::UpdateContainerResourcesRequest* request, ::runtime::v1alpha2::UpdateContainerResourcesResponse* response) { return this->UpdateContainerResources(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateContainerResources(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::UpdateContainerResourcesRequest, ::runtime::v1alpha2::UpdateContainerResourcesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::UpdateContainerResourcesRequest, ::runtime::v1alpha2::UpdateContainerResourcesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateContainerResources() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateContainerResources(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::UpdateContainerResourcesRequest* /*request*/, ::runtime::v1alpha2::UpdateContainerResourcesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateContainerResources(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::UpdateContainerResourcesRequest* /*request*/, ::runtime::v1alpha2::UpdateContainerResourcesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ReopenContainerLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ReopenContainerLog() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ReopenContainerLogRequest, ::runtime::v1alpha2::ReopenContainerLogResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::ReopenContainerLogRequest* request, ::runtime::v1alpha2::ReopenContainerLogResponse* response) { return this->ReopenContainerLog(context, request, response); }));}
    void SetMessageAllocatorFor_ReopenContainerLog(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::ReopenContainerLogRequest, ::runtime::v1alpha2::ReopenContainerLogResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ReopenContainerLogRequest, ::runtime::v1alpha2::ReopenContainerLogResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ReopenContainerLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReopenContainerLog(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ReopenContainerLogRequest* /*request*/, ::runtime::v1alpha2::ReopenContainerLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReopenContainerLog(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::ReopenContainerLogRequest* /*request*/, ::runtime::v1alpha2::ReopenContainerLogResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ExecSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ExecSync() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ExecSyncRequest, ::runtime::v1alpha2::ExecSyncResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::ExecSyncRequest* request, ::runtime::v1alpha2::ExecSyncResponse* response) { return this->ExecSync(context, request, response); }));}
    void SetMessageAllocatorFor_ExecSync(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::ExecSyncRequest, ::runtime::v1alpha2::ExecSyncResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ExecSyncRequest, ::runtime::v1alpha2::ExecSyncResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ExecSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecSync(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ExecSyncRequest* /*request*/, ::runtime::v1alpha2::ExecSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExecSync(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::ExecSyncRequest* /*request*/, ::runtime::v1alpha2::ExecSyncResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Exec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Exec() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ExecRequest, ::runtime::v1alpha2::ExecResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::ExecRequest* request, ::runtime::v1alpha2::ExecResponse* response) { return this->Exec(context, request, response); }));}
    void SetMessageAllocatorFor_Exec(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::ExecRequest, ::runtime::v1alpha2::ExecResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ExecRequest, ::runtime::v1alpha2::ExecResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Exec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Exec(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ExecRequest* /*request*/, ::runtime::v1alpha2::ExecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Exec(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::ExecRequest* /*request*/, ::runtime::v1alpha2::ExecResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Attach : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Attach() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::AttachRequest, ::runtime::v1alpha2::AttachResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::AttachRequest* request, ::runtime::v1alpha2::AttachResponse* response) { return this->Attach(context, request, response); }));}
    void SetMessageAllocatorFor_Attach(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::AttachRequest, ::runtime::v1alpha2::AttachResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::AttachRequest, ::runtime::v1alpha2::AttachResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Attach() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Attach(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::AttachRequest* /*request*/, ::runtime::v1alpha2::AttachResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Attach(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::AttachRequest* /*request*/, ::runtime::v1alpha2::AttachResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PortForward : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PortForward() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::PortForwardRequest, ::runtime::v1alpha2::PortForwardResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::PortForwardRequest* request, ::runtime::v1alpha2::PortForwardResponse* response) { return this->PortForward(context, request, response); }));}
    void SetMessageAllocatorFor_PortForward(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::PortForwardRequest, ::runtime::v1alpha2::PortForwardResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::PortForwardRequest, ::runtime::v1alpha2::PortForwardResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PortForward() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortForward(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PortForwardRequest* /*request*/, ::runtime::v1alpha2::PortForwardResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PortForward(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::PortForwardRequest* /*request*/, ::runtime::v1alpha2::PortForwardResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ContainerStats() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ContainerStatsRequest, ::runtime::v1alpha2::ContainerStatsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::ContainerStatsRequest* request, ::runtime::v1alpha2::ContainerStatsResponse* response) { return this->ContainerStats(context, request, response); }));}
    void SetMessageAllocatorFor_ContainerStats(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::ContainerStatsRequest, ::runtime::v1alpha2::ContainerStatsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ContainerStatsRequest, ::runtime::v1alpha2::ContainerStatsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContainerStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ContainerStatsRequest* /*request*/, ::runtime::v1alpha2::ContainerStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ContainerStats(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::ContainerStatsRequest* /*request*/, ::runtime::v1alpha2::ContainerStatsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListContainerStats() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ListContainerStatsRequest, ::runtime::v1alpha2::ListContainerStatsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::ListContainerStatsRequest* request, ::runtime::v1alpha2::ListContainerStatsResponse* response) { return this->ListContainerStats(context, request, response); }));}
    void SetMessageAllocatorFor_ListContainerStats(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::ListContainerStatsRequest, ::runtime::v1alpha2::ListContainerStatsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ListContainerStatsRequest, ::runtime::v1alpha2::ListContainerStatsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListContainerStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListContainerStatsRequest* /*request*/, ::runtime::v1alpha2::ListContainerStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListContainerStats(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::ListContainerStatsRequest* /*request*/, ::runtime::v1alpha2::ListContainerStatsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PodSandboxStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PodSandboxStats() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::PodSandboxStatsRequest, ::runtime::v1alpha2::PodSandboxStatsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::PodSandboxStatsRequest* request, ::runtime::v1alpha2::PodSandboxStatsResponse* response) { return this->PodSandboxStats(context, request, response); }));}
    void SetMessageAllocatorFor_PodSandboxStats(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::PodSandboxStatsRequest, ::runtime::v1alpha2::PodSandboxStatsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::PodSandboxStatsRequest, ::runtime::v1alpha2::PodSandboxStatsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PodSandboxStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PodSandboxStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PodSandboxStatsRequest* /*request*/, ::runtime::v1alpha2::PodSandboxStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PodSandboxStats(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::PodSandboxStatsRequest* /*request*/, ::runtime::v1alpha2::PodSandboxStatsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListPodSandboxStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListPodSandboxStats() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ListPodSandboxStatsRequest, ::runtime::v1alpha2::ListPodSandboxStatsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::ListPodSandboxStatsRequest* request, ::runtime::v1alpha2::ListPodSandboxStatsResponse* response) { return this->ListPodSandboxStats(context, request, response); }));}
    void SetMessageAllocatorFor_ListPodSandboxStats(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::ListPodSandboxStatsRequest, ::runtime::v1alpha2::ListPodSandboxStatsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ListPodSandboxStatsRequest, ::runtime::v1alpha2::ListPodSandboxStatsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListPodSandboxStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPodSandboxStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListPodSandboxStatsRequest* /*request*/, ::runtime::v1alpha2::ListPodSandboxStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListPodSandboxStats(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::ListPodSandboxStatsRequest* /*request*/, ::runtime::v1alpha2::ListPodSandboxStatsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateRuntimeConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateRuntimeConfig() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::UpdateRuntimeConfigRequest, ::runtime::v1alpha2::UpdateRuntimeConfigResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest* request, ::runtime::v1alpha2::UpdateRuntimeConfigResponse* response) { return this->UpdateRuntimeConfig(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateRuntimeConfig(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::UpdateRuntimeConfigRequest, ::runtime::v1alpha2::UpdateRuntimeConfigResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::UpdateRuntimeConfigRequest, ::runtime::v1alpha2::UpdateRuntimeConfigResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateRuntimeConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateRuntimeConfig(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest* /*request*/, ::runtime::v1alpha2::UpdateRuntimeConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateRuntimeConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest* /*request*/, ::runtime::v1alpha2::UpdateRuntimeConfigResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Status() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::StatusRequest, ::runtime::v1alpha2::StatusResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::StatusRequest* request, ::runtime::v1alpha2::StatusResponse* response) { return this->Status(context, request, response); }));}
    void SetMessageAllocatorFor_Status(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::StatusRequest, ::runtime::v1alpha2::StatusResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::StatusRequest, ::runtime::v1alpha2::StatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Status(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StatusRequest* /*request*/, ::runtime::v1alpha2::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Status(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::StatusRequest* /*request*/, ::runtime::v1alpha2::StatusResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Version<WithCallbackMethod_RunPodSandbox<WithCallbackMethod_StopPodSandbox<WithCallbackMethod_RemovePodSandbox<WithCallbackMethod_PodSandboxStatus<WithCallbackMethod_ListPodSandbox<WithCallbackMethod_CreateContainer<WithCallbackMethod_StartContainer<WithCallbackMethod_StopContainer<WithCallbackMethod_RemoveContainer<WithCallbackMethod_ListContainers<WithCallbackMethod_ContainerStatus<WithCallbackMethod_UpdateContainerResources<WithCallbackMethod_ReopenContainerLog<WithCallbackMethod_ExecSync<WithCallbackMethod_Exec<WithCallbackMethod_Attach<WithCallbackMethod_PortForward<WithCallbackMethod_ContainerStats<WithCallbackMethod_ListContainerStats<WithCallbackMethod_PodSandboxStats<WithCallbackMethod_ListPodSandboxStats<WithCallbackMethod_UpdateRuntimeConfig<WithCallbackMethod_Status<Service > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Version() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::VersionRequest* /*request*/, ::runtime::v1alpha2::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RunPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RunPodSandbox() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_RunPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RunPodSandboxRequest* /*request*/, ::runtime::v1alpha2::RunPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopPodSandbox() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_StopPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StopPodSandboxRequest* /*request*/, ::runtime::v1alpha2::StopPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemovePodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemovePodSandbox() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_RemovePodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemovePodSandboxRequest* /*request*/, ::runtime::v1alpha2::RemovePodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PodSandboxStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PodSandboxStatus() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_PodSandboxStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PodSandboxStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PodSandboxStatusRequest* /*request*/, ::runtime::v1alpha2::PodSandboxStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListPodSandbox() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ListPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListPodSandboxRequest* /*request*/, ::runtime::v1alpha2::ListPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateContainer() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::CreateContainerRequest* /*request*/, ::runtime::v1alpha2::CreateContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartContainer() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_StartContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StartContainerRequest* /*request*/, ::runtime::v1alpha2::StartContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopContainer() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_StopContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StopContainerRequest* /*request*/, ::runtime::v1alpha2::StopContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemoveContainer() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_RemoveContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemoveContainerRequest* /*request*/, ::runtime::v1alpha2::RemoveContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListContainers() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_ListContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListContainers(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListContainersRequest* /*request*/, ::runtime::v1alpha2::ListContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ContainerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ContainerStatus() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_ContainerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContainerStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ContainerStatusRequest* /*request*/, ::runtime::v1alpha2::ContainerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateContainerResources : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateContainerResources() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_UpdateContainerResources() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateContainerResources(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::UpdateContainerResourcesRequest* /*request*/, ::runtime::v1alpha2::UpdateContainerResourcesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReopenContainerLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReopenContainerLog() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_ReopenContainerLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReopenContainerLog(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ReopenContainerLogRequest* /*request*/, ::runtime::v1alpha2::ReopenContainerLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExecSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExecSync() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_ExecSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecSync(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ExecSyncRequest* /*request*/, ::runtime::v1alpha2::ExecSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Exec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Exec() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_Exec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Exec(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ExecRequest* /*request*/, ::runtime::v1alpha2::ExecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Attach : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Attach() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_Attach() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Attach(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::AttachRequest* /*request*/, ::runtime::v1alpha2::AttachResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PortForward : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PortForward() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_PortForward() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortForward(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PortForwardRequest* /*request*/, ::runtime::v1alpha2::PortForwardResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ContainerStats() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_ContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContainerStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ContainerStatsRequest* /*request*/, ::runtime::v1alpha2::ContainerStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListContainerStats() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_ListContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListContainerStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListContainerStatsRequest* /*request*/, ::runtime::v1alpha2::ListContainerStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PodSandboxStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PodSandboxStats() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_PodSandboxStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PodSandboxStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PodSandboxStatsRequest* /*request*/, ::runtime::v1alpha2::PodSandboxStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListPodSandboxStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListPodSandboxStats() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_ListPodSandboxStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPodSandboxStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListPodSandboxStatsRequest* /*request*/, ::runtime::v1alpha2::ListPodSandboxStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateRuntimeConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateRuntimeConfig() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_UpdateRuntimeConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateRuntimeConfig(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest* /*request*/, ::runtime::v1alpha2::UpdateRuntimeConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Status() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_Status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Status(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StatusRequest* /*request*/, ::runtime::v1alpha2::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Version() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::VersionRequest* /*request*/, ::runtime::v1alpha2::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RunPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RunPodSandbox() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_RunPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RunPodSandboxRequest* /*request*/, ::runtime::v1alpha2::RunPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunPodSandbox(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopPodSandbox() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_StopPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StopPodSandboxRequest* /*request*/, ::runtime::v1alpha2::StopPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopPodSandbox(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemovePodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemovePodSandbox() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_RemovePodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemovePodSandboxRequest* /*request*/, ::runtime::v1alpha2::RemovePodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemovePodSandbox(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PodSandboxStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PodSandboxStatus() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_PodSandboxStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PodSandboxStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PodSandboxStatusRequest* /*request*/, ::runtime::v1alpha2::PodSandboxStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPodSandboxStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListPodSandbox() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ListPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListPodSandboxRequest* /*request*/, ::runtime::v1alpha2::ListPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListPodSandbox(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateContainer() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::CreateContainerRequest* /*request*/, ::runtime::v1alpha2::CreateContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateContainer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartContainer() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_StartContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StartContainerRequest* /*request*/, ::runtime::v1alpha2::StartContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartContainer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopContainer() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_StopContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StopContainerRequest* /*request*/, ::runtime::v1alpha2::StopContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopContainer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoveContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemoveContainer() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_RemoveContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemoveContainerRequest* /*request*/, ::runtime::v1alpha2::RemoveContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveContainer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListContainers() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_ListContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListContainers(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListContainersRequest* /*request*/, ::runtime::v1alpha2::ListContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListContainers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ContainerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ContainerStatus() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_ContainerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContainerStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ContainerStatusRequest* /*request*/, ::runtime::v1alpha2::ContainerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestContainerStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateContainerResources : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateContainerResources() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_UpdateContainerResources() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateContainerResources(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::UpdateContainerResourcesRequest* /*request*/, ::runtime::v1alpha2::UpdateContainerResourcesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateContainerResources(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReopenContainerLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReopenContainerLog() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_ReopenContainerLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReopenContainerLog(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ReopenContainerLogRequest* /*request*/, ::runtime::v1alpha2::ReopenContainerLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReopenContainerLog(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExecSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExecSync() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_ExecSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecSync(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ExecSyncRequest* /*request*/, ::runtime::v1alpha2::ExecSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecSync(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Exec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Exec() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_Exec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Exec(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ExecRequest* /*request*/, ::runtime::v1alpha2::ExecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExec(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Attach : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Attach() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_Attach() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Attach(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::AttachRequest* /*request*/, ::runtime::v1alpha2::AttachResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAttach(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PortForward : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PortForward() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_PortForward() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortForward(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PortForwardRequest* /*request*/, ::runtime::v1alpha2::PortForwardResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPortForward(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ContainerStats() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_ContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContainerStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ContainerStatsRequest* /*request*/, ::runtime::v1alpha2::ContainerStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestContainerStats(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListContainerStats() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_ListContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListContainerStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListContainerStatsRequest* /*request*/, ::runtime::v1alpha2::ListContainerStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListContainerStats(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PodSandboxStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PodSandboxStats() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_PodSandboxStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PodSandboxStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PodSandboxStatsRequest* /*request*/, ::runtime::v1alpha2::PodSandboxStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPodSandboxStats(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListPodSandboxStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListPodSandboxStats() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_ListPodSandboxStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPodSandboxStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListPodSandboxStatsRequest* /*request*/, ::runtime::v1alpha2::ListPodSandboxStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListPodSandboxStats(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateRuntimeConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateRuntimeConfig() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_UpdateRuntimeConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateRuntimeConfig(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest* /*request*/, ::runtime::v1alpha2::UpdateRuntimeConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateRuntimeConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Status() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_Status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Status(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StatusRequest* /*request*/, ::runtime::v1alpha2::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Version() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Version(context, request, response); }));
    }
    ~WithRawCallbackMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::VersionRequest* /*request*/, ::runtime::v1alpha2::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Version(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RunPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RunPodSandbox() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RunPodSandbox(context, request, response); }));
    }
    ~WithRawCallbackMethod_RunPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RunPodSandboxRequest* /*request*/, ::runtime::v1alpha2::RunPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RunPodSandbox(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StopPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StopPodSandbox() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopPodSandbox(context, request, response); }));
    }
    ~WithRawCallbackMethod_StopPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StopPodSandboxRequest* /*request*/, ::runtime::v1alpha2::StopPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopPodSandbox(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RemovePodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RemovePodSandbox() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemovePodSandbox(context, request, response); }));
    }
    ~WithRawCallbackMethod_RemovePodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemovePodSandboxRequest* /*request*/, ::runtime::v1alpha2::RemovePodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemovePodSandbox(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PodSandboxStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PodSandboxStatus() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PodSandboxStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_PodSandboxStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PodSandboxStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PodSandboxStatusRequest* /*request*/, ::runtime::v1alpha2::PodSandboxStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PodSandboxStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListPodSandbox() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListPodSandbox(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListPodSandboxRequest* /*request*/, ::runtime::v1alpha2::ListPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListPodSandbox(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateContainer() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateContainer(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::CreateContainerRequest* /*request*/, ::runtime::v1alpha2::CreateContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateContainer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StartContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StartContainer() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartContainer(context, request, response); }));
    }
    ~WithRawCallbackMethod_StartContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StartContainerRequest* /*request*/, ::runtime::v1alpha2::StartContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartContainer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StopContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StopContainer() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopContainer(context, request, response); }));
    }
    ~WithRawCallbackMethod_StopContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StopContainerRequest* /*request*/, ::runtime::v1alpha2::StopContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopContainer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RemoveContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RemoveContainer() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemoveContainer(context, request, response); }));
    }
    ~WithRawCallbackMethod_RemoveContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemoveContainerRequest* /*request*/, ::runtime::v1alpha2::RemoveContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemoveContainer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListContainers() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListContainers(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListContainers(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListContainersRequest* /*request*/, ::runtime::v1alpha2::ListContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListContainers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ContainerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ContainerStatus() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ContainerStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_ContainerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContainerStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ContainerStatusRequest* /*request*/, ::runtime::v1alpha2::ContainerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ContainerStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateContainerResources : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateContainerResources() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateContainerResources(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateContainerResources() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateContainerResources(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::UpdateContainerResourcesRequest* /*request*/, ::runtime::v1alpha2::UpdateContainerResourcesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateContainerResources(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ReopenContainerLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ReopenContainerLog() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReopenContainerLog(context, request, response); }));
    }
    ~WithRawCallbackMethod_ReopenContainerLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReopenContainerLog(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ReopenContainerLogRequest* /*request*/, ::runtime::v1alpha2::ReopenContainerLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReopenContainerLog(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ExecSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ExecSync() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExecSync(context, request, response); }));
    }
    ~WithRawCallbackMethod_ExecSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecSync(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ExecSyncRequest* /*request*/, ::runtime::v1alpha2::ExecSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExecSync(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Exec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Exec() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Exec(context, request, response); }));
    }
    ~WithRawCallbackMethod_Exec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Exec(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ExecRequest* /*request*/, ::runtime::v1alpha2::ExecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Exec(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Attach : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Attach() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Attach(context, request, response); }));
    }
    ~WithRawCallbackMethod_Attach() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Attach(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::AttachRequest* /*request*/, ::runtime::v1alpha2::AttachResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Attach(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PortForward : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PortForward() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PortForward(context, request, response); }));
    }
    ~WithRawCallbackMethod_PortForward() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortForward(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PortForwardRequest* /*request*/, ::runtime::v1alpha2::PortForwardResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PortForward(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ContainerStats() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ContainerStats(context, request, response); }));
    }
    ~WithRawCallbackMethod_ContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContainerStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ContainerStatsRequest* /*request*/, ::runtime::v1alpha2::ContainerStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ContainerStats(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListContainerStats() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListContainerStats(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListContainerStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListContainerStatsRequest* /*request*/, ::runtime::v1alpha2::ListContainerStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListContainerStats(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PodSandboxStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PodSandboxStats() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PodSandboxStats(context, request, response); }));
    }
    ~WithRawCallbackMethod_PodSandboxStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PodSandboxStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PodSandboxStatsRequest* /*request*/, ::runtime::v1alpha2::PodSandboxStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PodSandboxStats(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListPodSandboxStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListPodSandboxStats() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListPodSandboxStats(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListPodSandboxStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPodSandboxStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListPodSandboxStatsRequest* /*request*/, ::runtime::v1alpha2::ListPodSandboxStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListPodSandboxStats(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateRuntimeConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateRuntimeConfig() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateRuntimeConfig(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateRuntimeConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateRuntimeConfig(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest* /*request*/, ::runtime::v1alpha2::UpdateRuntimeConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateRuntimeConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Status() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Status(context, request, response); }));
    }
    ~WithRawCallbackMethod_Status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Status(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StatusRequest* /*request*/, ::runtime::v1alpha2::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Status(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Version() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::VersionRequest, ::runtime::v1alpha2::VersionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::VersionRequest, ::runtime::v1alpha2::VersionResponse>* streamer) {
                       return this->StreamedVersion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::VersionRequest* /*request*/, ::runtime::v1alpha2::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::VersionRequest,::runtime::v1alpha2::VersionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RunPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RunPodSandbox() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::RunPodSandboxRequest, ::runtime::v1alpha2::RunPodSandboxResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::RunPodSandboxRequest, ::runtime::v1alpha2::RunPodSandboxResponse>* streamer) {
                       return this->StreamedRunPodSandbox(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RunPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RunPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RunPodSandboxRequest* /*request*/, ::runtime::v1alpha2::RunPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRunPodSandbox(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::RunPodSandboxRequest,::runtime::v1alpha2::RunPodSandboxResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopPodSandbox() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::StopPodSandboxRequest, ::runtime::v1alpha2::StopPodSandboxResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::StopPodSandboxRequest, ::runtime::v1alpha2::StopPodSandboxResponse>* streamer) {
                       return this->StreamedStopPodSandbox(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StopPodSandboxRequest* /*request*/, ::runtime::v1alpha2::StopPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopPodSandbox(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::StopPodSandboxRequest,::runtime::v1alpha2::StopPodSandboxResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemovePodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemovePodSandbox() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::RemovePodSandboxRequest, ::runtime::v1alpha2::RemovePodSandboxResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::RemovePodSandboxRequest, ::runtime::v1alpha2::RemovePodSandboxResponse>* streamer) {
                       return this->StreamedRemovePodSandbox(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemovePodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemovePodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemovePodSandboxRequest* /*request*/, ::runtime::v1alpha2::RemovePodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemovePodSandbox(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::RemovePodSandboxRequest,::runtime::v1alpha2::RemovePodSandboxResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PodSandboxStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PodSandboxStatus() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::PodSandboxStatusRequest, ::runtime::v1alpha2::PodSandboxStatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::PodSandboxStatusRequest, ::runtime::v1alpha2::PodSandboxStatusResponse>* streamer) {
                       return this->StreamedPodSandboxStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PodSandboxStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PodSandboxStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PodSandboxStatusRequest* /*request*/, ::runtime::v1alpha2::PodSandboxStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPodSandboxStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::PodSandboxStatusRequest,::runtime::v1alpha2::PodSandboxStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListPodSandbox() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::ListPodSandboxRequest, ::runtime::v1alpha2::ListPodSandboxResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::ListPodSandboxRequest, ::runtime::v1alpha2::ListPodSandboxResponse>* streamer) {
                       return this->StreamedListPodSandbox(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListPodSandbox(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListPodSandboxRequest* /*request*/, ::runtime::v1alpha2::ListPodSandboxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListPodSandbox(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::ListPodSandboxRequest,::runtime::v1alpha2::ListPodSandboxResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateContainer() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::CreateContainerRequest, ::runtime::v1alpha2::CreateContainerResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::CreateContainerRequest, ::runtime::v1alpha2::CreateContainerResponse>* streamer) {
                       return this->StreamedCreateContainer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::CreateContainerRequest* /*request*/, ::runtime::v1alpha2::CreateContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateContainer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::CreateContainerRequest,::runtime::v1alpha2::CreateContainerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartContainer() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::StartContainerRequest, ::runtime::v1alpha2::StartContainerResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::StartContainerRequest, ::runtime::v1alpha2::StartContainerResponse>* streamer) {
                       return this->StreamedStartContainer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StartContainerRequest* /*request*/, ::runtime::v1alpha2::StartContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartContainer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::StartContainerRequest,::runtime::v1alpha2::StartContainerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopContainer() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::StopContainerRequest, ::runtime::v1alpha2::StopContainerResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::StopContainerRequest, ::runtime::v1alpha2::StopContainerResponse>* streamer) {
                       return this->StreamedStopContainer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StopContainerRequest* /*request*/, ::runtime::v1alpha2::StopContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopContainer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::StopContainerRequest,::runtime::v1alpha2::StopContainerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemoveContainer() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::RemoveContainerRequest, ::runtime::v1alpha2::RemoveContainerResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::RemoveContainerRequest, ::runtime::v1alpha2::RemoveContainerResponse>* streamer) {
                       return this->StreamedRemoveContainer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemoveContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveContainer(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemoveContainerRequest* /*request*/, ::runtime::v1alpha2::RemoveContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveContainer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::RemoveContainerRequest,::runtime::v1alpha2::RemoveContainerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListContainers() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::ListContainersRequest, ::runtime::v1alpha2::ListContainersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::ListContainersRequest, ::runtime::v1alpha2::ListContainersResponse>* streamer) {
                       return this->StreamedListContainers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListContainers(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListContainersRequest* /*request*/, ::runtime::v1alpha2::ListContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListContainers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::ListContainersRequest,::runtime::v1alpha2::ListContainersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ContainerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ContainerStatus() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::ContainerStatusRequest, ::runtime::v1alpha2::ContainerStatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::ContainerStatusRequest, ::runtime::v1alpha2::ContainerStatusResponse>* streamer) {
                       return this->StreamedContainerStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ContainerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ContainerStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ContainerStatusRequest* /*request*/, ::runtime::v1alpha2::ContainerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedContainerStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::ContainerStatusRequest,::runtime::v1alpha2::ContainerStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateContainerResources : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateContainerResources() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::UpdateContainerResourcesRequest, ::runtime::v1alpha2::UpdateContainerResourcesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::UpdateContainerResourcesRequest, ::runtime::v1alpha2::UpdateContainerResourcesResponse>* streamer) {
                       return this->StreamedUpdateContainerResources(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateContainerResources() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateContainerResources(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::UpdateContainerResourcesRequest* /*request*/, ::runtime::v1alpha2::UpdateContainerResourcesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateContainerResources(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::UpdateContainerResourcesRequest,::runtime::v1alpha2::UpdateContainerResourcesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReopenContainerLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReopenContainerLog() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::ReopenContainerLogRequest, ::runtime::v1alpha2::ReopenContainerLogResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::ReopenContainerLogRequest, ::runtime::v1alpha2::ReopenContainerLogResponse>* streamer) {
                       return this->StreamedReopenContainerLog(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReopenContainerLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReopenContainerLog(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ReopenContainerLogRequest* /*request*/, ::runtime::v1alpha2::ReopenContainerLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReopenContainerLog(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::ReopenContainerLogRequest,::runtime::v1alpha2::ReopenContainerLogResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExecSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExecSync() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::ExecSyncRequest, ::runtime::v1alpha2::ExecSyncResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::ExecSyncRequest, ::runtime::v1alpha2::ExecSyncResponse>* streamer) {
                       return this->StreamedExecSync(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExecSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExecSync(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ExecSyncRequest* /*request*/, ::runtime::v1alpha2::ExecSyncResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecSync(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::ExecSyncRequest,::runtime::v1alpha2::ExecSyncResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Exec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Exec() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::ExecRequest, ::runtime::v1alpha2::ExecResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::ExecRequest, ::runtime::v1alpha2::ExecResponse>* streamer) {
                       return this->StreamedExec(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Exec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Exec(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ExecRequest* /*request*/, ::runtime::v1alpha2::ExecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExec(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::ExecRequest,::runtime::v1alpha2::ExecResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Attach : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Attach() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::AttachRequest, ::runtime::v1alpha2::AttachResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::AttachRequest, ::runtime::v1alpha2::AttachResponse>* streamer) {
                       return this->StreamedAttach(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Attach() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Attach(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::AttachRequest* /*request*/, ::runtime::v1alpha2::AttachResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAttach(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::AttachRequest,::runtime::v1alpha2::AttachResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PortForward : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PortForward() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::PortForwardRequest, ::runtime::v1alpha2::PortForwardResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::PortForwardRequest, ::runtime::v1alpha2::PortForwardResponse>* streamer) {
                       return this->StreamedPortForward(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PortForward() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PortForward(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PortForwardRequest* /*request*/, ::runtime::v1alpha2::PortForwardResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPortForward(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::PortForwardRequest,::runtime::v1alpha2::PortForwardResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ContainerStats() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::ContainerStatsRequest, ::runtime::v1alpha2::ContainerStatsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::ContainerStatsRequest, ::runtime::v1alpha2::ContainerStatsResponse>* streamer) {
                       return this->StreamedContainerStats(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ContainerStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ContainerStatsRequest* /*request*/, ::runtime::v1alpha2::ContainerStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedContainerStats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::ContainerStatsRequest,::runtime::v1alpha2::ContainerStatsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListContainerStats() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::ListContainerStatsRequest, ::runtime::v1alpha2::ListContainerStatsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::ListContainerStatsRequest, ::runtime::v1alpha2::ListContainerStatsResponse>* streamer) {
                       return this->StreamedListContainerStats(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListContainerStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListContainerStatsRequest* /*request*/, ::runtime::v1alpha2::ListContainerStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListContainerStats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::ListContainerStatsRequest,::runtime::v1alpha2::ListContainerStatsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PodSandboxStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PodSandboxStats() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::PodSandboxStatsRequest, ::runtime::v1alpha2::PodSandboxStatsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::PodSandboxStatsRequest, ::runtime::v1alpha2::PodSandboxStatsResponse>* streamer) {
                       return this->StreamedPodSandboxStats(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PodSandboxStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PodSandboxStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PodSandboxStatsRequest* /*request*/, ::runtime::v1alpha2::PodSandboxStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPodSandboxStats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::PodSandboxStatsRequest,::runtime::v1alpha2::PodSandboxStatsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListPodSandboxStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListPodSandboxStats() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::ListPodSandboxStatsRequest, ::runtime::v1alpha2::ListPodSandboxStatsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::ListPodSandboxStatsRequest, ::runtime::v1alpha2::ListPodSandboxStatsResponse>* streamer) {
                       return this->StreamedListPodSandboxStats(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListPodSandboxStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListPodSandboxStats(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListPodSandboxStatsRequest* /*request*/, ::runtime::v1alpha2::ListPodSandboxStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListPodSandboxStats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::ListPodSandboxStatsRequest,::runtime::v1alpha2::ListPodSandboxStatsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateRuntimeConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateRuntimeConfig() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::UpdateRuntimeConfigRequest, ::runtime::v1alpha2::UpdateRuntimeConfigResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::UpdateRuntimeConfigRequest, ::runtime::v1alpha2::UpdateRuntimeConfigResponse>* streamer) {
                       return this->StreamedUpdateRuntimeConfig(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateRuntimeConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateRuntimeConfig(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::UpdateRuntimeConfigRequest* /*request*/, ::runtime::v1alpha2::UpdateRuntimeConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateRuntimeConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::UpdateRuntimeConfigRequest,::runtime::v1alpha2::UpdateRuntimeConfigResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Status() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::StatusRequest, ::runtime::v1alpha2::StatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::StatusRequest, ::runtime::v1alpha2::StatusResponse>* streamer) {
                       return this->StreamedStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Status(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::StatusRequest* /*request*/, ::runtime::v1alpha2::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::StatusRequest,::runtime::v1alpha2::StatusResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Version<WithStreamedUnaryMethod_RunPodSandbox<WithStreamedUnaryMethod_StopPodSandbox<WithStreamedUnaryMethod_RemovePodSandbox<WithStreamedUnaryMethod_PodSandboxStatus<WithStreamedUnaryMethod_ListPodSandbox<WithStreamedUnaryMethod_CreateContainer<WithStreamedUnaryMethod_StartContainer<WithStreamedUnaryMethod_StopContainer<WithStreamedUnaryMethod_RemoveContainer<WithStreamedUnaryMethod_ListContainers<WithStreamedUnaryMethod_ContainerStatus<WithStreamedUnaryMethod_UpdateContainerResources<WithStreamedUnaryMethod_ReopenContainerLog<WithStreamedUnaryMethod_ExecSync<WithStreamedUnaryMethod_Exec<WithStreamedUnaryMethod_Attach<WithStreamedUnaryMethod_PortForward<WithStreamedUnaryMethod_ContainerStats<WithStreamedUnaryMethod_ListContainerStats<WithStreamedUnaryMethod_PodSandboxStats<WithStreamedUnaryMethod_ListPodSandboxStats<WithStreamedUnaryMethod_UpdateRuntimeConfig<WithStreamedUnaryMethod_Status<Service > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Version<WithStreamedUnaryMethod_RunPodSandbox<WithStreamedUnaryMethod_StopPodSandbox<WithStreamedUnaryMethod_RemovePodSandbox<WithStreamedUnaryMethod_PodSandboxStatus<WithStreamedUnaryMethod_ListPodSandbox<WithStreamedUnaryMethod_CreateContainer<WithStreamedUnaryMethod_StartContainer<WithStreamedUnaryMethod_StopContainer<WithStreamedUnaryMethod_RemoveContainer<WithStreamedUnaryMethod_ListContainers<WithStreamedUnaryMethod_ContainerStatus<WithStreamedUnaryMethod_UpdateContainerResources<WithStreamedUnaryMethod_ReopenContainerLog<WithStreamedUnaryMethod_ExecSync<WithStreamedUnaryMethod_Exec<WithStreamedUnaryMethod_Attach<WithStreamedUnaryMethod_PortForward<WithStreamedUnaryMethod_ContainerStats<WithStreamedUnaryMethod_ListContainerStats<WithStreamedUnaryMethod_PodSandboxStats<WithStreamedUnaryMethod_ListPodSandboxStats<WithStreamedUnaryMethod_UpdateRuntimeConfig<WithStreamedUnaryMethod_Status<Service > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

// ImageService defines the public APIs for managing images.
class ImageService final {
 public:
  static constexpr char const* service_full_name() {
    return "runtime.v1alpha2.ImageService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // ListImages lists existing images.
    virtual ::grpc::Status ListImages(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListImagesRequest& request, ::runtime::v1alpha2::ListImagesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListImagesResponse>> AsyncListImages(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListImagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListImagesResponse>>(AsyncListImagesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListImagesResponse>> PrepareAsyncListImages(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListImagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListImagesResponse>>(PrepareAsyncListImagesRaw(context, request, cq));
    }
    // ImageStatus returns the status of the image. If the image is not
    // present, returns a response with ImageStatusResponse.Image set to
    // nil.
    virtual ::grpc::Status ImageStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageStatusRequest& request, ::runtime::v1alpha2::ImageStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ImageStatusResponse>> AsyncImageStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ImageStatusResponse>>(AsyncImageStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ImageStatusResponse>> PrepareAsyncImageStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ImageStatusResponse>>(PrepareAsyncImageStatusRaw(context, request, cq));
    }
    // PullImage pulls an image with authentication config.
    virtual ::grpc::Status PullImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::PullImageRequest& request, ::runtime::v1alpha2::PullImageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PullImageResponse>> AsyncPullImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::PullImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PullImageResponse>>(AsyncPullImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PullImageResponse>> PrepareAsyncPullImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::PullImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PullImageResponse>>(PrepareAsyncPullImageRaw(context, request, cq));
    }
    // RemoveImage removes the image.
    // This call is idempotent, and must not return an error if the image has
    // already been removed.
    virtual ::grpc::Status RemoveImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveImageRequest& request, ::runtime::v1alpha2::RemoveImageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemoveImageResponse>> AsyncRemoveImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemoveImageResponse>>(AsyncRemoveImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemoveImageResponse>> PrepareAsyncRemoveImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemoveImageResponse>>(PrepareAsyncRemoveImageRaw(context, request, cq));
    }
    // ImageFSInfo returns information of the filesystem that is used to store images.
    virtual ::grpc::Status ImageFsInfo(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageFsInfoRequest& request, ::runtime::v1alpha2::ImageFsInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ImageFsInfoResponse>> AsyncImageFsInfo(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageFsInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ImageFsInfoResponse>>(AsyncImageFsInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ImageFsInfoResponse>> PrepareAsyncImageFsInfo(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageFsInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ImageFsInfoResponse>>(PrepareAsyncImageFsInfoRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // ListImages lists existing images.
      virtual void ListImages(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListImagesRequest* request, ::runtime::v1alpha2::ListImagesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListImages(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListImagesRequest* request, ::runtime::v1alpha2::ListImagesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ImageStatus returns the status of the image. If the image is not
      // present, returns a response with ImageStatusResponse.Image set to
      // nil.
      virtual void ImageStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageStatusRequest* request, ::runtime::v1alpha2::ImageStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ImageStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageStatusRequest* request, ::runtime::v1alpha2::ImageStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // PullImage pulls an image with authentication config.
      virtual void PullImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::PullImageRequest* request, ::runtime::v1alpha2::PullImageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PullImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::PullImageRequest* request, ::runtime::v1alpha2::PullImageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // RemoveImage removes the image.
      // This call is idempotent, and must not return an error if the image has
      // already been removed.
      virtual void RemoveImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveImageRequest* request, ::runtime::v1alpha2::RemoveImageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RemoveImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveImageRequest* request, ::runtime::v1alpha2::RemoveImageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ImageFSInfo returns information of the filesystem that is used to store images.
      virtual void ImageFsInfo(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageFsInfoRequest* request, ::runtime::v1alpha2::ImageFsInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ImageFsInfo(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageFsInfoRequest* request, ::runtime::v1alpha2::ImageFsInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListImagesResponse>* AsyncListImagesRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListImagesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ListImagesResponse>* PrepareAsyncListImagesRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListImagesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ImageStatusResponse>* AsyncImageStatusRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ImageStatusResponse>* PrepareAsyncImageStatusRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PullImageResponse>* AsyncPullImageRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::PullImageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::PullImageResponse>* PrepareAsyncPullImageRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::PullImageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemoveImageResponse>* AsyncRemoveImageRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveImageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::RemoveImageResponse>* PrepareAsyncRemoveImageRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveImageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ImageFsInfoResponse>* AsyncImageFsInfoRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageFsInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::v1alpha2::ImageFsInfoResponse>* PrepareAsyncImageFsInfoRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageFsInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status ListImages(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListImagesRequest& request, ::runtime::v1alpha2::ListImagesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListImagesResponse>> AsyncListImages(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListImagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListImagesResponse>>(AsyncListImagesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListImagesResponse>> PrepareAsyncListImages(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListImagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListImagesResponse>>(PrepareAsyncListImagesRaw(context, request, cq));
    }
    ::grpc::Status ImageStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageStatusRequest& request, ::runtime::v1alpha2::ImageStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ImageStatusResponse>> AsyncImageStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ImageStatusResponse>>(AsyncImageStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ImageStatusResponse>> PrepareAsyncImageStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ImageStatusResponse>>(PrepareAsyncImageStatusRaw(context, request, cq));
    }
    ::grpc::Status PullImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::PullImageRequest& request, ::runtime::v1alpha2::PullImageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PullImageResponse>> AsyncPullImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::PullImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PullImageResponse>>(AsyncPullImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PullImageResponse>> PrepareAsyncPullImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::PullImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PullImageResponse>>(PrepareAsyncPullImageRaw(context, request, cq));
    }
    ::grpc::Status RemoveImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveImageRequest& request, ::runtime::v1alpha2::RemoveImageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemoveImageResponse>> AsyncRemoveImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemoveImageResponse>>(AsyncRemoveImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemoveImageResponse>> PrepareAsyncRemoveImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemoveImageResponse>>(PrepareAsyncRemoveImageRaw(context, request, cq));
    }
    ::grpc::Status ImageFsInfo(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageFsInfoRequest& request, ::runtime::v1alpha2::ImageFsInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ImageFsInfoResponse>> AsyncImageFsInfo(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageFsInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ImageFsInfoResponse>>(AsyncImageFsInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ImageFsInfoResponse>> PrepareAsyncImageFsInfo(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageFsInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ImageFsInfoResponse>>(PrepareAsyncImageFsInfoRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void ListImages(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListImagesRequest* request, ::runtime::v1alpha2::ListImagesResponse* response, std::function<void(::grpc::Status)>) override;
      void ListImages(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListImagesRequest* request, ::runtime::v1alpha2::ListImagesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ImageStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageStatusRequest* request, ::runtime::v1alpha2::ImageStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void ImageStatus(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageStatusRequest* request, ::runtime::v1alpha2::ImageStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PullImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::PullImageRequest* request, ::runtime::v1alpha2::PullImageResponse* response, std::function<void(::grpc::Status)>) override;
      void PullImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::PullImageRequest* request, ::runtime::v1alpha2::PullImageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RemoveImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveImageRequest* request, ::runtime::v1alpha2::RemoveImageResponse* response, std::function<void(::grpc::Status)>) override;
      void RemoveImage(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveImageRequest* request, ::runtime::v1alpha2::RemoveImageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ImageFsInfo(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageFsInfoRequest* request, ::runtime::v1alpha2::ImageFsInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void ImageFsInfo(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageFsInfoRequest* request, ::runtime::v1alpha2::ImageFsInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListImagesResponse>* AsyncListImagesRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListImagesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ListImagesResponse>* PrepareAsyncListImagesRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ListImagesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ImageStatusResponse>* AsyncImageStatusRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ImageStatusResponse>* PrepareAsyncImageStatusRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PullImageResponse>* AsyncPullImageRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::PullImageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::PullImageResponse>* PrepareAsyncPullImageRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::PullImageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemoveImageResponse>* AsyncRemoveImageRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveImageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::RemoveImageResponse>* PrepareAsyncRemoveImageRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::RemoveImageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ImageFsInfoResponse>* AsyncImageFsInfoRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageFsInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::v1alpha2::ImageFsInfoResponse>* PrepareAsyncImageFsInfoRaw(::grpc::ClientContext* context, const ::runtime::v1alpha2::ImageFsInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ListImages_;
    const ::grpc::internal::RpcMethod rpcmethod_ImageStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_PullImage_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveImage_;
    const ::grpc::internal::RpcMethod rpcmethod_ImageFsInfo_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // ListImages lists existing images.
    virtual ::grpc::Status ListImages(::grpc::ServerContext* context, const ::runtime::v1alpha2::ListImagesRequest* request, ::runtime::v1alpha2::ListImagesResponse* response);
    // ImageStatus returns the status of the image. If the image is not
    // present, returns a response with ImageStatusResponse.Image set to
    // nil.
    virtual ::grpc::Status ImageStatus(::grpc::ServerContext* context, const ::runtime::v1alpha2::ImageStatusRequest* request, ::runtime::v1alpha2::ImageStatusResponse* response);
    // PullImage pulls an image with authentication config.
    virtual ::grpc::Status PullImage(::grpc::ServerContext* context, const ::runtime::v1alpha2::PullImageRequest* request, ::runtime::v1alpha2::PullImageResponse* response);
    // RemoveImage removes the image.
    // This call is idempotent, and must not return an error if the image has
    // already been removed.
    virtual ::grpc::Status RemoveImage(::grpc::ServerContext* context, const ::runtime::v1alpha2::RemoveImageRequest* request, ::runtime::v1alpha2::RemoveImageResponse* response);
    // ImageFSInfo returns information of the filesystem that is used to store images.
    virtual ::grpc::Status ImageFsInfo(::grpc::ServerContext* context, const ::runtime::v1alpha2::ImageFsInfoRequest* request, ::runtime::v1alpha2::ImageFsInfoResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ListImages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListImages() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ListImages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListImages(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListImagesRequest* /*request*/, ::runtime::v1alpha2::ListImagesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListImages(::grpc::ServerContext* context, ::runtime::v1alpha2::ListImagesRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::ListImagesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImageStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImageStatus() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ImageStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ImageStatusRequest* /*request*/, ::runtime::v1alpha2::ImageStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImageStatus(::grpc::ServerContext* context, ::runtime::v1alpha2::ImageStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::ImageStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PullImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PullImage() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_PullImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PullImage(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PullImageRequest* /*request*/, ::runtime::v1alpha2::PullImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPullImage(::grpc::ServerContext* context, ::runtime::v1alpha2::PullImageRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::PullImageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemoveImage() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_RemoveImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveImage(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemoveImageRequest* /*request*/, ::runtime::v1alpha2::RemoveImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveImage(::grpc::ServerContext* context, ::runtime::v1alpha2::RemoveImageRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::RemoveImageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImageFsInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImageFsInfo() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ImageFsInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageFsInfo(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ImageFsInfoRequest* /*request*/, ::runtime::v1alpha2::ImageFsInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImageFsInfo(::grpc::ServerContext* context, ::runtime::v1alpha2::ImageFsInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::v1alpha2::ImageFsInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ListImages<WithAsyncMethod_ImageStatus<WithAsyncMethod_PullImage<WithAsyncMethod_RemoveImage<WithAsyncMethod_ImageFsInfo<Service > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_ListImages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListImages() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ListImagesRequest, ::runtime::v1alpha2::ListImagesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::ListImagesRequest* request, ::runtime::v1alpha2::ListImagesResponse* response) { return this->ListImages(context, request, response); }));}
    void SetMessageAllocatorFor_ListImages(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::ListImagesRequest, ::runtime::v1alpha2::ListImagesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ListImagesRequest, ::runtime::v1alpha2::ListImagesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListImages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListImages(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListImagesRequest* /*request*/, ::runtime::v1alpha2::ListImagesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListImages(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::ListImagesRequest* /*request*/, ::runtime::v1alpha2::ListImagesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ImageStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ImageStatus() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ImageStatusRequest, ::runtime::v1alpha2::ImageStatusResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::ImageStatusRequest* request, ::runtime::v1alpha2::ImageStatusResponse* response) { return this->ImageStatus(context, request, response); }));}
    void SetMessageAllocatorFor_ImageStatus(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::ImageStatusRequest, ::runtime::v1alpha2::ImageStatusResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ImageStatusRequest, ::runtime::v1alpha2::ImageStatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ImageStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ImageStatusRequest* /*request*/, ::runtime::v1alpha2::ImageStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ImageStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::ImageStatusRequest* /*request*/, ::runtime::v1alpha2::ImageStatusResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PullImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PullImage() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::PullImageRequest, ::runtime::v1alpha2::PullImageResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::PullImageRequest* request, ::runtime::v1alpha2::PullImageResponse* response) { return this->PullImage(context, request, response); }));}
    void SetMessageAllocatorFor_PullImage(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::PullImageRequest, ::runtime::v1alpha2::PullImageResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::PullImageRequest, ::runtime::v1alpha2::PullImageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PullImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PullImage(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PullImageRequest* /*request*/, ::runtime::v1alpha2::PullImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PullImage(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::PullImageRequest* /*request*/, ::runtime::v1alpha2::PullImageResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RemoveImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RemoveImage() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::RemoveImageRequest, ::runtime::v1alpha2::RemoveImageResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::RemoveImageRequest* request, ::runtime::v1alpha2::RemoveImageResponse* response) { return this->RemoveImage(context, request, response); }));}
    void SetMessageAllocatorFor_RemoveImage(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::RemoveImageRequest, ::runtime::v1alpha2::RemoveImageResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::RemoveImageRequest, ::runtime::v1alpha2::RemoveImageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RemoveImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveImage(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemoveImageRequest* /*request*/, ::runtime::v1alpha2::RemoveImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemoveImage(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::RemoveImageRequest* /*request*/, ::runtime::v1alpha2::RemoveImageResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ImageFsInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ImageFsInfo() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ImageFsInfoRequest, ::runtime::v1alpha2::ImageFsInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::runtime::v1alpha2::ImageFsInfoRequest* request, ::runtime::v1alpha2::ImageFsInfoResponse* response) { return this->ImageFsInfo(context, request, response); }));}
    void SetMessageAllocatorFor_ImageFsInfo(
        ::grpc::MessageAllocator< ::runtime::v1alpha2::ImageFsInfoRequest, ::runtime::v1alpha2::ImageFsInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::runtime::v1alpha2::ImageFsInfoRequest, ::runtime::v1alpha2::ImageFsInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ImageFsInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageFsInfo(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ImageFsInfoRequest* /*request*/, ::runtime::v1alpha2::ImageFsInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ImageFsInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::runtime::v1alpha2::ImageFsInfoRequest* /*request*/, ::runtime::v1alpha2::ImageFsInfoResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_ListImages<WithCallbackMethod_ImageStatus<WithCallbackMethod_PullImage<WithCallbackMethod_RemoveImage<WithCallbackMethod_ImageFsInfo<Service > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ListImages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListImages() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ListImages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListImages(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListImagesRequest* /*request*/, ::runtime::v1alpha2::ListImagesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImageStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImageStatus() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ImageStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ImageStatusRequest* /*request*/, ::runtime::v1alpha2::ImageStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PullImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PullImage() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_PullImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PullImage(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PullImageRequest* /*request*/, ::runtime::v1alpha2::PullImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemoveImage() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_RemoveImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveImage(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemoveImageRequest* /*request*/, ::runtime::v1alpha2::RemoveImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImageFsInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImageFsInfo() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ImageFsInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageFsInfo(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ImageFsInfoRequest* /*request*/, ::runtime::v1alpha2::ImageFsInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListImages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListImages() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ListImages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListImages(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListImagesRequest* /*request*/, ::runtime::v1alpha2::ListImagesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListImages(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImageStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImageStatus() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_ImageStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ImageStatusRequest* /*request*/, ::runtime::v1alpha2::ImageStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImageStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PullImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PullImage() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_PullImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PullImage(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PullImageRequest* /*request*/, ::runtime::v1alpha2::PullImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPullImage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoveImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemoveImage() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_RemoveImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveImage(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemoveImageRequest* /*request*/, ::runtime::v1alpha2::RemoveImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveImage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImageFsInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImageFsInfo() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ImageFsInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageFsInfo(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ImageFsInfoRequest* /*request*/, ::runtime::v1alpha2::ImageFsInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImageFsInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListImages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListImages() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListImages(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListImages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListImages(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListImagesRequest* /*request*/, ::runtime::v1alpha2::ListImagesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListImages(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ImageStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ImageStatus() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImageStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_ImageStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ImageStatusRequest* /*request*/, ::runtime::v1alpha2::ImageStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ImageStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PullImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PullImage() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PullImage(context, request, response); }));
    }
    ~WithRawCallbackMethod_PullImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PullImage(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PullImageRequest* /*request*/, ::runtime::v1alpha2::PullImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PullImage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RemoveImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RemoveImage() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemoveImage(context, request, response); }));
    }
    ~WithRawCallbackMethod_RemoveImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveImage(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemoveImageRequest* /*request*/, ::runtime::v1alpha2::RemoveImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemoveImage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ImageFsInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ImageFsInfo() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImageFsInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_ImageFsInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageFsInfo(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ImageFsInfoRequest* /*request*/, ::runtime::v1alpha2::ImageFsInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ImageFsInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListImages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListImages() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::ListImagesRequest, ::runtime::v1alpha2::ListImagesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::ListImagesRequest, ::runtime::v1alpha2::ListImagesResponse>* streamer) {
                       return this->StreamedListImages(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListImages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListImages(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ListImagesRequest* /*request*/, ::runtime::v1alpha2::ListImagesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListImages(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::ListImagesRequest,::runtime::v1alpha2::ListImagesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImageStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImageStatus() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::ImageStatusRequest, ::runtime::v1alpha2::ImageStatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::ImageStatusRequest, ::runtime::v1alpha2::ImageStatusResponse>* streamer) {
                       return this->StreamedImageStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImageStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImageStatus(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ImageStatusRequest* /*request*/, ::runtime::v1alpha2::ImageStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImageStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::ImageStatusRequest,::runtime::v1alpha2::ImageStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PullImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PullImage() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::PullImageRequest, ::runtime::v1alpha2::PullImageResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::PullImageRequest, ::runtime::v1alpha2::PullImageResponse>* streamer) {
                       return this->StreamedPullImage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PullImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PullImage(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::PullImageRequest* /*request*/, ::runtime::v1alpha2::PullImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPullImage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::PullImageRequest,::runtime::v1alpha2::PullImageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemoveImage() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::RemoveImageRequest, ::runtime::v1alpha2::RemoveImageResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::RemoveImageRequest, ::runtime::v1alpha2::RemoveImageResponse>* streamer) {
                       return this->StreamedRemoveImage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemoveImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveImage(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::RemoveImageRequest* /*request*/, ::runtime::v1alpha2::RemoveImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveImage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::RemoveImageRequest,::runtime::v1alpha2::RemoveImageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImageFsInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImageFsInfo() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::runtime::v1alpha2::ImageFsInfoRequest, ::runtime::v1alpha2::ImageFsInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::runtime::v1alpha2::ImageFsInfoRequest, ::runtime::v1alpha2::ImageFsInfoResponse>* streamer) {
                       return this->StreamedImageFsInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImageFsInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImageFsInfo(::grpc::ServerContext* /*context*/, const ::runtime::v1alpha2::ImageFsInfoRequest* /*request*/, ::runtime::v1alpha2::ImageFsInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImageFsInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::v1alpha2::ImageFsInfoRequest,::runtime::v1alpha2::ImageFsInfoResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ListImages<WithStreamedUnaryMethod_ImageStatus<WithStreamedUnaryMethod_PullImage<WithStreamedUnaryMethod_RemoveImage<WithStreamedUnaryMethod_ImageFsInfo<Service > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ListImages<WithStreamedUnaryMethod_ImageStatus<WithStreamedUnaryMethod_PullImage<WithStreamedUnaryMethod_RemoveImage<WithStreamedUnaryMethod_ImageFsInfo<Service > > > > > StreamedService;
};

}  // namespace v1alpha2
}  // namespace runtime


#endif  // GRPC_api_2eproto__INCLUDED
